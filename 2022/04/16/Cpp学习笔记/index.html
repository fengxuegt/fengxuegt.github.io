<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="Cpp学习笔记" />


<!-- Website keywords -->

<meta name="keywords" content="Cpp, 枫雪gt" />




<!-- Website rss -->

<link rel="alternate" href="/default" title="枫雪gt" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="http://example.com/2022/04/16/Cpp学习笔记/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>Cpp学习笔记 - 枫雪gt</title>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">枫雪gt</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">枫雪gt</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      Cpp学习笔记
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2022-04-16
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/Technology/">Technology</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">第一章 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">虚拟地址空间划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">函数调用堆栈过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A51"><span class="toc-number">1.3.</span> <span class="toc-text">编译和链接1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A52"><span class="toc-number">1.4.</span> <span class="toc-text">编译和链接2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B2%BE%E8%AE%B2"><span class="toc-number">2.</span> <span class="toc-text">第二章 基础知识精讲</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#new-delete"><span class="toc-number">2.1.</span> <span class="toc-text">new&#x2F;delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.2.</span> <span class="toc-text">C++的引用和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC"><span class="toc-number">2.2.1.</span> <span class="toc-text">左值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC"><span class="toc-number">2.2.2.</span> <span class="toc-text">右值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">const 指针 引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">形参带默认值的函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">第三章 C++面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-this%E6%8C%87%E9%92%88"><span class="toc-number">3.1.</span> <span class="toc-text">类和对象+this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">构造函数和析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.3.</span> <span class="toc-text">深浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.4.</span> <span class="toc-text">代码应用实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">3.5.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.6.</span> <span class="toc-text">指向类成员的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%90%84%E7%A7%8D%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.</span> <span class="toc-text">类的各种成员方法及区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-C-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">第四章 C++模板编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.1.</span> <span class="toc-text">理解函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.1.1.</span> <span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.1.2.</span> <span class="toc-text">模板实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">模板函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.4.</span> <span class="toc-text">模板类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.5.</span> <span class="toc-text">模板非类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%BC%94"><span class="toc-number">4.1.6.</span> <span class="toc-text">模板的实参推演</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-number">4.1.7.</span> <span class="toc-text">模板特例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0-%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96-%E9%9D%9E%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.8.</span> <span class="toc-text">模板函数&#x2F;模板特例化&#x2F;非模板函数的重载关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.9.</span> <span class="toc-text">分文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E7%B1%BB%E6%A8%A1%E6%9D%BF-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">理解类模板 + 空间配置器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">第五章 C++运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">复数类的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text">string类型的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.</span> <span class="toc-text">Vector类型的迭代器实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%EF%BC%9F-%E8%A6%81%E5%90%8E%E9%9D%A2%E5%86%8D%E7%9C%8B%E7%9C%8B"><span class="toc-number">5.4.</span> <span class="toc-text">迭代器的失效问题？ 要后面再看看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cdelete"><span class="toc-number">5.5.</span> <span class="toc-text">new和delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cdelete%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%BA%94%E7%94%A8"><span class="toc-number">5.6.</span> <span class="toc-text">new和delete实现的对象池应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-OOP"><span class="toc-number">6.</span> <span class="toc-text">第六章 OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">继承的本质和原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">派生类的构造过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E3%80%81%E9%9A%90%E8%97%8F"><span class="toc-number">6.3.</span> <span class="toc-text">重载、覆盖、隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E3%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">6.4.</span> <span class="toc-text">虚函数、静态绑定、动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.</span> <span class="toc-text">虚函数和动态绑定问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.6.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81"><span class="toc-number">6.7.</span> <span class="toc-text">如何理解多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.8.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">6.9.</span> <span class="toc-text">面试题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB%E5%92%8C%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">6.10.</span> <span class="toc-text">虚基类和虚继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-C-STL"><span class="toc-number">7.</span> <span class="toc-text">第七章 C++ STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-number">7.1.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dequeue%E5%92%8Clist"><span class="toc-number">7.2.</span> <span class="toc-text">dequeue和list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%92%8Cdequeue%E5%AF%B9%E6%AF%94"><span class="toc-number">7.3.</span> <span class="toc-text">vector和dequeue对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">容器适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">7.5.</span> <span class="toc-text">容器迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.6.</span> <span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E5%92%8C%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-number">7.7.</span> <span class="toc-text">泛型算法和绑定器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">第8章 面试问题</span></a></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <p><strong>写在前面</strong></p>
<p>本篇blog是学习C++过程中所记录下来的重点，便于后续回顾。笔记来自于施磊老师的C++视频课程；</p>
<span id="more"></span>
<h1 id="第一章-前置知识"><a href="#第一章-前置知识" class="headerlink" title="第一章 前置知识"></a>第一章 前置知识</h1><h2 id="虚拟地址空间划分"><a href="#虚拟地址空间划分" class="headerlink" title="虚拟地址空间划分"></a>虚拟地址空间划分</h2><img src="/2022/04/16/Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/address.png" class title="image">
<p>上图是虚拟地址空间的一个划分的图；<br>对于左侧程序中的各种变量来讲：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int gdata1 = 10; // .data</span><br><span class="line">int gdata2 = 0; // .bss 虽然初始化了但是初始化为0</span><br><span class="line">int gdata3; // .bss</span><br><span class="line"></span><br><span class="line">static int gdata4 = 11; // .data</span><br><span class="line">static int gdata5 = 0; // .bss 虽然初始化了但是初始化为0</span><br><span class="line">static int gdata6; // .bss</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 12; // mov指令 .data ;存储在文件时是在.data段中，只是在程序运行的时候在栈上分配内存来存储12这个值。</span><br><span class="line">	int b = 0; // mvo指令</span><br><span class="line">	int c; // mov指令</span><br><span class="line">	</span><br><span class="line">	static int e = 13; // .data</span><br><span class="line">	static int f = 0; // .bss</span><br><span class="line">	static int g; // .bss</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几句经典的话；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">它存在，你能看见：它是物理的</span><br><span class="line">它存在，你看不见；它是透明的</span><br><span class="line">它不存在，你能看见，它是虚拟的（虚拟地址空间）</span><br><span class="line">它不存在，你看不见，它被删除了</span><br><span class="line">注意：内核空间进程是共享的，用户空间是独立的；</span><br></pre></td></tr></table></figure>
<h2 id="函数调用堆栈过程"><a href="#函数调用堆栈过程" class="headerlink" title="函数调用堆栈过程"></a>函数调用堆栈过程</h2><p>问题一：main函数调用sum，sum执行完以后，怎么知道回到哪个函数中？</p>
<p>问题二：sum函数执行完以后，回到main之后，如何知道从哪一行重新开始执行？</p>
<p>ffffffv</p>
<h2 id="编译和链接1"><a href="#编译和链接1" class="headerlink" title="编译和链接1"></a>编译和链接1</h2><h2 id="编译和链接2"><a href="#编译和链接2" class="headerlink" title="编译和链接2"></a>编译和链接2</h2><h1 id="第二章-基础知识精讲"><a href="#第二章-基础知识精讲" class="headerlink" title="第二章 基础知识精讲"></a>第二章 基础知识精讲</h1><h2 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h2><p>new和malloc的区别是什么？<br>delete和free的区别是什么？</p>
<p>malloc和free是C语言的库函数<br>new和delete被称为是C++的运算符</p>
<p>new不仅仅可以开辟内存，还可以做内存的初始化操作<br>malloc开辟内存失败，是通过返回值和nullptr做比较；而new开辟内存失败，是通过抛出bad_alloc异常来判断的；</p>
<p>new有多少种？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *p = new int(20);</span><br><span class="line">int *p = new (nothrow) int;</span><br><span class="line">const int *p = new const int(40);</span><br><span class="line"></span><br><span class="line">int data = 0; // 定位new</span><br><span class="line">int *p = new (&amp;data) int (50);</span><br></pre></td></tr></table></figure>
<h2 id="C-的引用和指针"><a href="#C-的引用和指针" class="headerlink" title="C++的引用和指针"></a>C++的引用和指针</h2><p>1、左值引用和右值引用<br>2、引用的实例</p>
<p>引用是一种更安全的指针<br>1、引用是必须初始化的，指针可以不初始化<br>2、引用只有一级引用，没有多级引用；指针可以有一级指针，也可以有多级指针<br>3、定义一个引用变量，和定义一个指针变量，其汇编指令是一模一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的</p>
<p>定义指向数组的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int arr[5] = &#123;&#125;;</span><br><span class="line">int *p = arr;</span><br><span class="line">int (&amp;q)[5] = arr;</span><br><span class="line">cout &lt;&lt; sizeof(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sizeof(q) &lt;&lt; endl;</span><br><span class="line">==============================</span><br><span class="line">20</span><br><span class="line">8</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>有内存、有名字、值可以修改</p>
<h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>没内存、没名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp; c = 20;</span><br><span class="line">const int &amp;d = 20;</span><br><span class="line">// 以上两行代码的底层汇编指令是一模一样的；只不过不能通过d来修改变量，而可以通过c来修改；</span><br></pre></td></tr></table></figure>
<p>1、int &amp;&amp; c = 20；专门用来引用右值类型，指令上可以自动产生临时量，然后直接引用临时量；<br>2、右值引用本身是一个左值，只能用左值引用来引用它<br>3、不能用一个右值引用变量，来引用一个左值</p>
<h2 id="const-指针-引用"><a href="#const-指针-引用" class="headerlink" title="const 指针 引用"></a>const 指针 引用</h2><p>const怎么理解？<br>const修饰的变量，不能够再作为左值，初始化完成之后，值不能再被修改；</p>
<p>c和c++中const的区别是什么？</p>
<h2 id="形参带默认值的函数"><a href="#形参带默认值的函数" class="headerlink" title="形参带默认值的函数"></a>形参带默认值的函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数总是默认从右向左给</span><br><span class="line">调用效率的问题</span><br><span class="line">定义处可以给默认值，声明处也可以</span><br><span class="line">形参给默认值时，无论是定义还是声明给定，形参默认值只能出现一次；不能重复出现</span><br></pre></td></tr></table></figure>
<h1 id="第三章-C-面向对象"><a href="#第三章-C-面向对象" class="headerlink" title="第三章 C++面向对象"></a>第三章 C++面向对象</h1><h2 id="类和对象-this指针"><a href="#类和对象-this指针" class="headerlink" title="类和对象+this指针"></a>类和对象+this指针</h2><p>this指针 =》 类 =〉 很多对象 公用一套成员方法<br>成员方法，方法的参数中都会添加一个this指针（静态成员函数除外）</p>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>定义对象时，自动调用构造函数；没有返回值，调用结束之后，对象就产生了；<br>析构函数，不带参数，不能重载，只能有一个析构函数，析构完成之后，对象就不存在了；<br>.data对象<br>heap new delete<br>stack</p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>浅拷贝，是做内存地址的拷贝；在类中含有动态内存时会出现错误；因此必须自己实现深拷贝。</p>
<h2 id="代码应用实践"><a href="#代码应用实践" class="headerlink" title="代码应用实践"></a>代码应用实践</h2><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>成员变量的初始化方式和他们定义的顺序有关；和构造函数初始化列表中出现的顺序无关；<br>构造函数初始化列表，可以指定当前对象成员变量的初始化方式；</p>
<h2 id="指向类成员的指针"><a href="#指向类成员的指针" class="headerlink" title="指向类成员的指针"></a>指向类成员的指针</h2><h2 id="类的各种成员方法及区别"><a href="#类的各种成员方法及区别" class="headerlink" title="类的各种成员方法及区别"></a>类的各种成员方法及区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">普通的成员函数 =》编译器会添加一个this指针</span><br><span class="line">属于类的作用域</span><br><span class="line">调用该方法时，需要依赖一个对象（常对象无法调用；因为this指针无法指向const对象；常对象只能调用常成员函数）</span><br><span class="line">可以任意访问对象的私有</span><br></pre></td></tr></table></figure>
<h1 id="第四章-C-模板编程"><a href="#第四章-C-模板编程" class="headerlink" title="第四章 C++模板编程"></a>第四章 C++模板编程</h1><h2 id="理解函数模板"><a href="#理解函数模板" class="headerlink" title="理解函数模板"></a>理解函数模板</h2><p>模板的意义：针对类型进行参数化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">template&lt;typename T&gt; // 定义模板参数列表</span><br><span class="line">bool compare(T a, T b) // compare是一个函数模板</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;template compare&quot; &lt;&lt; endl;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    在函数调用点，编译器用用户指定的类型，从原模板实例化一份函数代码出来；因此每个类型，都会实例化一份函数代码</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 实现const char *类型的特例化，编译器实现的代码不符合逻辑要求</span><br><span class="line">template&lt;&gt;</span><br><span class="line">bool compare(const char *a, const char *b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;compare&lt;const char *&gt;&quot; &lt;&lt; endl;</span><br><span class="line">    return strcmp(a, b) &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line">// 非模板函数，普通函数</span><br><span class="line">bool compare(const char *a, const char *b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;not template&quot; &lt;&lt; endl;</span><br><span class="line">    return strcmp(a, b) &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    compare&lt;int&gt; (1, 3); // int 可以省略</span><br><span class="line">    compare&lt;int&gt; (1.3, 4); // 可以运行，但是有warning，强制类型转换</span><br><span class="line">    // compare(1.3, 4); // 这里是不能运行的，因为无法推演出实参</span><br><span class="line">    compare(30, 2);</span><br><span class="line">    // 对于某些类型来说，依赖编译器默认实现代码逻辑是不符合预期的，比如对于const char *，应该实现为strcmp（a，b）</span><br><span class="line">    // 需要实现模板的特例化</span><br><span class="line">    // 编译器优先把compare 处理成函数名字，没有的话再去找函数模板，如果有类型参数传入的话，那肯定是函数模板；</span><br><span class="line">    compare(&quot;aaa&quot;, &quot;bbb&quot;); // 这里实参推演是const char * ，比较的是两个指针的大小；模板特例化之后实现的是strcmp了</span><br><span class="line">    compare&lt;const char *&gt; (&quot;aaa&quot;, &quot;bbb&quot;); // 这里用特例化版本；上面那个用非模板函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>无法编译，因为不知道类型</p>
<h3 id="模板实例化"><a href="#模板实例化" class="headerlink" title="模板实例化"></a>模板实例化</h3><p>函数调用点进行实例化</p>
<h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><p>才是真正被编译器所编译的</p>
<h3 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h3><p>typename/class</p>
<h3 id="模板非类型参数"><a href="#模板非类型参数" class="headerlink" title="模板非类型参数"></a>模板非类型参数</h3><p>必须是常量，只能使用，不能修改；<br>而且必须是整数类型（整数或者地址/引用都可以）</p>
<h3 id="模板的实参推演"><a href="#模板的实参推演" class="headerlink" title="模板的实参推演"></a>模板的实参推演</h3><p>可以根据用户传入的实参的类型，来推导出模板类型参数的具体类型</p>
<h3 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h3><p>当编译器实现的默认逻辑代码无法满足特殊类型的要求时，需要自行实现；这就是模板的特例化</p>
<h3 id="模板函数-模板特例化-非模板函数的重载关系"><a href="#模板函数-模板特例化-非模板函数的重载关系" class="headerlink" title="模板函数/模板特例化/非模板函数的重载关系"></a>模板函数/模板特例化/非模板函数的重载关系</h3><p>代码中一般comapre和特例化compare构成重载关系；但是跟非模板函数不构成重载关系</p>
<h3 id="分文件"><a href="#分文件" class="headerlink" title="分文件"></a>分文件</h3><p>模板代码不能够在一个文件定义，在另一个文件中使用的；<br>模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够正常的实例化，产生能够被编译器编译的代码<br>所以模板代码都是放在头文件中的，然后在源文件中直接进行#include包含<br>如果实在要分文件编写，那也是可以的；只不过要特殊实例化；在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 告诉编译器，进行指定类型的实例化;见template project</span><br><span class="line">template bool compare&lt;int&gt;(int, int);</span><br><span class="line">template bool compare&lt;double&gt;(double, double);</span><br></pre></td></tr></table></figure>
<h2 id="理解类模板-空间配置器"><a href="#理解类模板-空间配置器" class="headerlink" title="理解类模板 + 空间配置器"></a>理解类模板 + 空间配置器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Created 2022-04-24 22:17:16</span><br><span class="line"> * Author : fengxuegt</span><br><span class="line"> * Email : fengxuegt@163.com</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 容器，空间配置器allocator</span><br><span class="line">// 容器的空间配置器</span><br><span class="line">// 做四件事情： 内存开辟/内存释放    对象构造/对象析构</span><br><span class="line"></span><br><span class="line">// 定义容器的空间配置器材，和C++标准库的allocator实现一样</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Allocator &#123;</span><br><span class="line">public:</span><br><span class="line">    T *allocator(size_t size) // 只负责内存开辟</span><br><span class="line">    &#123;</span><br><span class="line">        return (T*) malloc(size * sizeof(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void deallocate(void *ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        free(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void construct(T *ptr, const T &amp;val) // 负责对象的构造</span><br><span class="line">    &#123;</span><br><span class="line">        new (ptr) T(val); // 定位new</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void destroy(T *ptr) // 负责对象的析构</span><br><span class="line">    &#123;</span><br><span class="line">        ptr-&gt;~T(); // ～T() 调用T类型的析构函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/*</span><br><span class="line">容器底层内存开辟，内存释放，对象构造，对象释放都通过空间配置器来实现</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">template&lt;typename T = int, typename Alloc = Allocator&lt;T&gt; &gt;</span><br><span class="line">class MyVector &#123;</span><br><span class="line">public:</span><br><span class="line">    MyVector(int size = 10)</span><br><span class="line">    &#123;</span><br><span class="line">        // 需要将内存分配和对象构造分开</span><br><span class="line">        // m_first = new T[size];</span><br><span class="line">        m_first = m_alloc.allocator(size);</span><br><span class="line">        m_last = m_first;</span><br><span class="line">        m_end = m_first + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyVector()</span><br><span class="line">    &#123;</span><br><span class="line">        // 析构容器有效的元素，然后释放m_first指向的内存空间</span><br><span class="line">        // delete []m_first;</span><br><span class="line">        int size = m_last - m_first;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            m_alloc.destroy(&amp;m_first[i]); // 将vector中的有效元素析构掉</span><br><span class="line">        &#125;</span><br><span class="line">        m_alloc.deallocate(m_first); // 释放堆上的内存</span><br><span class="line">        m_first = nullptr;</span><br><span class="line">        m_last = nullptr;</span><br><span class="line">        m_end = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector(const MyVector&lt;T&gt; &amp;vec)</span><br><span class="line">    &#123;</span><br><span class="line">        // m_first = new T[vec.m_end - vec.m_first];</span><br><span class="line">        m_first = m_alloc.allocator(vec.m_end - vec.m_first);</span><br><span class="line">        T *cur = m_first;</span><br><span class="line">        int len = m_last - m_first;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            // m_first[i] = vec.m_first[i];</span><br><span class="line">            m_alloc.construct(m_first + i, vec.m_first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        m_last = vec.m_last;</span><br><span class="line">        m_end = vec.m_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector&lt;T&gt; &amp; operator= (const MyVector&lt;T&gt; &amp;vec)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this == &amp;vec)</span><br><span class="line">            return *this;</span><br><span class="line">        // delete []m_first;</span><br><span class="line">        int size = m_last - m_first;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            m_alloc.destroy(&amp;m_first[i]); // 将vector中的有效元素析构掉</span><br><span class="line">        &#125;</span><br><span class="line">        m_alloc.deallocate(m_first); // 释放堆上的内存</span><br><span class="line">        m_first = m_alloc.allocator(vec.m_end - vec.m_first);</span><br><span class="line">        T *cur = m_first;</span><br><span class="line">        int len = m_last - m_first;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            // m_first[i] = vec.m_first[i];</span><br><span class="line">            m_alloc.construct(m_first + i, vec.m_first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        m_last = vec.m_last;</span><br><span class="line">        m_end = vec.m_end;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const T &amp;val)</span><br><span class="line">    &#123;</span><br><span class="line">        if (full())</span><br><span class="line">            expand();</span><br><span class="line">        // *m_last = val;</span><br><span class="line">        m_alloc.construct(m_last, val);</span><br><span class="line">        m_last++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        if (empty()) &#123;</span><br><span class="line">            throw &quot;vector is empty&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        m_last--;</span><br><span class="line">        m_alloc.destroy(m_last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() const</span><br><span class="line">    &#123;</span><br><span class="line">        return m_first == m_last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool full() const</span><br><span class="line">    &#123;</span><br><span class="line">        return m_last == m_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator[](const int index) const</span><br><span class="line">    &#123;</span><br><span class="line">        return m_first[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size() const &#123;return (m_last - m_first);&#125;</span><br><span class="line">    T back() const &#123;return *(m_last-1);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    T *m_first; // 指向数组起始位置</span><br><span class="line">    T *m_last; // 指向数组有效元素的后继位置</span><br><span class="line">    T *m_end; // 指向数组空间的后继位置</span><br><span class="line">    Alloc m_alloc; // 定义容器的空间配置器对象</span><br><span class="line"></span><br><span class="line">    void expand() // 容器的二倍扩容</span><br><span class="line">    &#123;</span><br><span class="line">        int size = m_end - m_first;</span><br><span class="line">        // T *tmp = new T[size * 2];</span><br><span class="line">        T *tmp = m_alloc.allocator(size * 2);</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            m_alloc.construct(tmp + i, m_first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        // delete []m_first;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            m_alloc.destroy(m_first + i);</span><br><span class="line">        &#125;</span><br><span class="line">        m_alloc.deallocate(m_first);</span><br><span class="line">        m_first = tmp;</span><br><span class="line">        m_end = m_first + size * 2;</span><br><span class="line">        m_last = m_first + size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Test()&#123;cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    ~Test()&#123;cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 需要将内存分配和对象构造分开，不然定义一个容器，就会构造很多对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">MyVector&lt;Test&gt; my; // 定义的时候直接构造对象，如果使用new的话</span><br><span class="line">Test t1, t2, t3;</span><br><span class="line">cout &lt;&lt; &quot;------------&quot; &lt;&lt; endl;</span><br><span class="line">my.push_back(t1);</span><br><span class="line">my.push_back(t2);</span><br><span class="line">my.push_back(t3);</span><br><span class="line">cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;</span><br><span class="line">my.pop_back(); // 这个地方应该要析构对象，而不是只移动指针，因为对象有可能存有指向其他地方的内存指针；</span><br><span class="line">                // 如果不析构，可能造成内存泄漏，但是不能使用delete析构，因为delte会在析构对象的同时把内存释放掉；</span><br><span class="line">                // 将对象的析构和内存释放也分离；</span><br><span class="line">cout &lt;&lt; &quot;------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">MyVector&lt;int&gt; vec;</span><br><span class="line">vec.push_back(1);</span><br><span class="line">vec.push_back(2);</span><br><span class="line">vec.push_back(3);</span><br><span class="line">vec.push_back(4);</span><br><span class="line">vec.push_back(5);</span><br><span class="line">vec.pop_back();</span><br><span class="line">vec[0] = 9;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    cout &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;---------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; vec.size() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; vec.back();</span><br><span class="line">#endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">为什么要使用空间配置器？</span><br><span class="line">因为使用new或者delete的话无法将内存分配和释放以及对象的构造和析构分开；</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h1 id="第五章-C-运算符重载"><a href="#第五章-C-运算符重载" class="headerlink" title="第五章 C++运算符重载"></a>第五章 C++运算符重载</h1><h2 id="复数类的实现"><a href="#复数类的实现" class="headerlink" title="复数类的实现"></a>复数类的实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    C++ 的运算符重载：使得对象表现的像内置类型一样</span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    T sum(T &amp;a, T &amp;b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class CComplex</span><br><span class="line">&#123;s</span><br><span class="line">    friend CComplex operator+(const CComplex &amp;lhs, const CComplex &amp;rhs);</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream &amp;out, const CComplex &amp;rhs);</span><br><span class="line">    friend istream&amp; operator&gt;&gt;(istream &amp;in, CComplex &amp;rhs);</span><br><span class="line">private:</span><br><span class="line">    int m_real;</span><br><span class="line">    int m_image;</span><br><span class="line">public:</span><br><span class="line">    CComplex(int real = 0, int image = 0):m_real(real), m_image(image) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~CComplex()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // CComplex operator+(const CComplex &amp;rhs) &#123;</span><br><span class="line">    //     CComplex res;</span><br><span class="line">    //     res.m_image = this-&gt;m_image + rhs.m_image;</span><br><span class="line">    //     res.m_real = this-&gt;m_real + rhs.m_real;</span><br><span class="line">    //     return res;</span><br><span class="line">    // &#125;</span><br><span class="line">    void show() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;real: &quot; &lt;&lt; m_real &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; &quot;image: &quot; &lt;&lt; m_image &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComplex&amp; operator++() &#123; // 前置++</span><br><span class="line">        this-&gt;m_image++;</span><br><span class="line">        this-&gt;m_real++;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComplex operator++(int) &#123; // 后置++</span><br><span class="line">        // CComplex tmp = *this;</span><br><span class="line">        // this-&gt;m_image++;</span><br><span class="line">        // this-&gt;m_real++;</span><br><span class="line">        // return tmp;</span><br><span class="line">        return CComplex(m_real++, m_image++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void operator+=(const CComplex &amp;rhs) &#123;</span><br><span class="line">        this-&gt;m_real += rhs.m_real;</span><br><span class="line">        this-&gt;m_image += rhs.m_image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;out, const CComplex &amp;rhs) &#123; // 重载对象输出</span><br><span class="line">    out &lt;&lt; &quot;real: &quot; &lt;&lt; rhs.m_real &lt;&lt; &quot; &quot;;</span><br><span class="line">    out &lt;&lt; &quot;image: &quot; &lt;&lt; rhs.m_image &lt;&lt; endl;</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CComplex operator+(const CComplex &amp;lhs, const CComplex &amp;rhs) &#123;</span><br><span class="line">    CComplex res;</span><br><span class="line">    res.m_real = lhs.m_real + rhs.m_real;</span><br><span class="line">    res.m_image = lhs.m_image + rhs.m_image;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; operator&gt;&gt;(istream &amp;in, CComplex &amp;rhs) &#123;</span><br><span class="line">    in &gt;&gt; rhs.m_real &gt;&gt; rhs.m_image;</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CComplex com1(10, 10);</span><br><span class="line">    CComplex com2(20, 10);</span><br><span class="line">    CComplex com3 = com1 + com2;</span><br><span class="line">    CComplex com4 = com1 + 44; // 等价于 com1.operator+(44); // 44 会自动转化成ccomplex类型</span><br><span class="line">    com4.show();</span><br><span class="line">    // 编译器在做对象运算的时候，会调用对象的运算符重载函数（优先调用成员方法）；如果没有成员方法，就在全局作用域中寻找合适的运算符重载函数；</span><br><span class="line">    // 如果有全局方法，则成员方法可以省略</span><br><span class="line">    CComplex com5 = 22 + com1;</span><br><span class="line">    com5.show();</span><br><span class="line"></span><br><span class="line">    com5 = com1++;</span><br><span class="line">    com1.show();</span><br><span class="line">    com5.show();</span><br><span class="line">    com5 = ++com1;</span><br><span class="line">    com1.show();</span><br><span class="line">    com5.show();</span><br><span class="line">    cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;</span><br><span class="line">    com1 += com2;</span><br><span class="line">    com1.show();</span><br><span class="line">    cout &lt;&lt; &quot;======&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; com1;</span><br><span class="line">    cout &lt;&lt; &quot;########&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; com1 &gt;&gt; com2;</span><br><span class="line">    cout &lt;&lt; com1 &lt;&lt; com2;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string类型的实现"><a href="#string类型的实现" class="headerlink" title="string类型的实现"></a>string类型的实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 实现自定义string对象</span><br><span class="line">class LWString</span><br><span class="line">&#123;</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream &amp;out, const LWString &amp;rhs);</span><br><span class="line">    friend LWString operator+(const LWString &amp;lhs, const LWString &amp;rhs);</span><br><span class="line">private:</span><br><span class="line">    char *m_str;</span><br><span class="line">public:</span><br><span class="line">    LWString(const char * str= nullptr);</span><br><span class="line">    ~LWString();</span><br><span class="line"></span><br><span class="line">    // LWString operator+(const LWString &amp;rhs) &#123;</span><br><span class="line">    //     this-&gt;m_str = new char[strlen(m_str) + strlen(rhs.m_str) + 1];</span><br><span class="line">    // &#125;</span><br><span class="line">    int length() const &#123; // const之后是否是const的对象都能够调用</span><br><span class="line">        return strlen(m_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LWString(const LWString &amp;rhs) &#123;</span><br><span class="line">        m_str = new char[rhs.length() + 1];</span><br><span class="line">        strcmp(m_str, rhs.m_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LWString&amp; operator=(const LWString &amp;rhs) &#123;</span><br><span class="line">        if (this == &amp;rhs) &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        delete[]m_str;</span><br><span class="line">        m_str = new char[strlen(rhs.m_str) + 1];</span><br><span class="line">        strcmp(m_str, rhs.m_str);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator&gt;(const LWString &amp;rhs) &#123;</span><br><span class="line">        if (strcmp(this-&gt;m_str, rhs.m_str) &gt; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    char&amp; operator[](int index) &#123; // 非const</span><br><span class="line">        return m_str[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char&amp; operator[](int index) const&#123; // const</span><br><span class="line">        return m_str[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char* c_str() const &#123; // 最后要写const</span><br><span class="line">        return m_str;</span><br><span class="line">    &#125;</span><br><span class="line">    // string类的自定义迭代器</span><br><span class="line">    class Iterator &#123;</span><br><span class="line">        public:</span><br><span class="line">            Iterator(char *p = nullptr) : m_ptr(p) &#123;&#125;</span><br><span class="line">            bool operator!=(const Iterator &amp;rhs) &#123;</span><br><span class="line">                return rhs.m_ptr != m_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            Iterator&amp; operator++() &#123;</span><br><span class="line">                ++m_ptr;</span><br><span class="line">                return *this;</span><br><span class="line">            &#125;</span><br><span class="line">            char&amp; operator*() &#123;</span><br><span class="line">                return *m_ptr;</span><br><span class="line">            &#125; </span><br><span class="line">        private:</span><br><span class="line">            char *m_ptr;</span><br><span class="line">    &#125;;</span><br><span class="line">    // begin方法是容器类的成员方法；返回的是迭代器对象而已；</span><br><span class="line">    // begin返回的是首个元素的指针</span><br><span class="line">    Iterator begin() &#123;</span><br><span class="line">        return Iterator(m_str);</span><br><span class="line">    &#125;</span><br><span class="line">    // end返回的是最后一个元素的下一个位置</span><br><span class="line">    Iterator end() &#123;</span><br><span class="line">        return Iterator(m_str + strlen(m_str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LWString operator+(const LWString &amp;lhs, const LWString &amp;rhs) &#123;</span><br><span class="line">    LWString tmp;</span><br><span class="line">    tmp.m_str = new char[lhs.length() + rhs.length() + 1];</span><br><span class="line">    strcpy(tmp.m_str, lhs.m_str);</span><br><span class="line">    char *cur = tmp.m_str + lhs.length();</span><br><span class="line">    strcpy(cur, rhs.m_str);</span><br><span class="line">    return tmp; // 这里不定义tmp的话有内存泄漏，定义tmp的话效率就特别低；</span><br><span class="line">    #if 0</span><br><span class="line">    char *buf = new char[lhs.length() + rhs.length() + 1];</span><br><span class="line">    strcpy(buf, lhs.m_str);</span><br><span class="line">    char *cur = buf + lhs.length();</span><br><span class="line">    strcpy(cur, rhs.m_str);</span><br><span class="line">    LWString tmp(buf);</span><br><span class="line">    delete []buf;</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;out, const LWString &amp;rhs) &#123;</span><br><span class="line">    out &lt;&lt; rhs.m_str;</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LWString::LWString(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">    if (str == nullptr) &#123;</span><br><span class="line">        m_str = new char[1];</span><br><span class="line">        m_str[0] = &#x27;\0&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        m_str = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(m_str, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LWString::~LWString()</span><br><span class="line">&#123;</span><br><span class="line">    delete[]m_str;</span><br><span class="line">    m_str = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LWString str = &quot;hello world&quot;; // str是一种容器，底层放了一组char</span><br><span class="line">    // 容器的迭代器类型</span><br><span class="line">    // 迭代器的作用就是提供一种统一的方式遍历所有的容器</span><br><span class="line">    auto it = str.begin();</span><br><span class="line">    for (; it != str.end(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    // C++11 foreach 的方式访问容器内部的元素</span><br><span class="line">    // foreach方式遍历的底层还是使用的迭代器进行遍历的</span><br><span class="line">    for (char ch : str) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">    LWString str1;</span><br><span class="line">    LWString str2 = &quot;aaa&quot;;</span><br><span class="line">    LWString str3 = &quot;bbb&quot;;</span><br><span class="line">    LWString str4 = str2 + str3;</span><br><span class="line">    LWString str5 = str2 + &quot;ccc&quot;;</span><br><span class="line">    LWString str6 = &quot;ddd&quot; + str2;</span><br><span class="line">    cout &lt;&lt; &quot;str6 &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">    if (str5 &gt; str6) &#123;</span><br><span class="line">        cout &lt;&lt; str5 &lt;&lt; &quot; &gt; &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; str5 &lt;&lt; &quot; &lt; &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int len = str6.length();</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; str6[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    char buf[1024] = &#123;0&#125;;</span><br><span class="line">    strcpy(buf, str6.c_str());</span><br><span class="line">    cout &lt;&lt; &quot;buf: &quot; &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">#endif</span><br><span class="line">    #if 0</span><br><span class="line">    string str1;</span><br><span class="line">    string str2 = &quot;aaa&quot;;</span><br><span class="line">    string str3 = &quot;bbb&quot;;</span><br><span class="line">    string str4 = str2 + str3;</span><br><span class="line">    string str5 = str2 + &quot;ccc&quot;;</span><br><span class="line">    string str6 = &quot;ddd&quot; + str2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;str6 &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">    if (str5 &gt; str6) &#123;</span><br><span class="line">        cout &lt;&lt; str5 &lt;&lt; &quot; &gt; &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; str5 &lt;&lt; &quot; &lt; &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int len = str6.length();</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; str6[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    char buf[1024] = &#123;0&#125;;</span><br><span class="line">    strcpy(buf, str6.c_str());</span><br><span class="line">    cout &lt;&lt; &quot;buf: &quot; &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    #endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vector类型的迭代器实现"><a href="#Vector类型的迭代器实现" class="headerlink" title="Vector类型的迭代器实现"></a>Vector类型的迭代器实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Iterator &#123;</span><br><span class="line">    Iterator(T *ptr = nullptr):m_ptr(ptr) &#123;&#125;</span><br><span class="line">    bool operator!=(const Iterator &amp;it) const &#123;</span><br><span class="line">        return m_ptr != it.m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator*() &#123;</span><br><span class="line">        return *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    void operator++() &#123;</span><br><span class="line">        ++m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    public:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line">Iterator begin() &#123;</span><br><span class="line">    return Iterator(m_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator end() &#123;</span><br><span class="line">    return Iterator(m_last);</span><br><span class="line">&#125;</span><br><span class="line">// 基本上跟string类型是相同的，因为底层数据结构都是数组</span><br></pre></td></tr></table></figure>
<h2 id="迭代器的失效问题？-要后面再看看"><a href="#迭代器的失效问题？-要后面再看看" class="headerlink" title="迭代器的失效问题？ 要后面再看看"></a><strong>迭代器的失效问题？</strong> 要后面再看看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">1、迭代器为什么会失效？</span><br><span class="line">a、当容器调用erase之后，当前位置到容器末尾元素的迭代器全部失效</span><br><span class="line">b、当容器调用insert之后，当前位置到容器末尾元素的迭代器全部失效</span><br><span class="line">首元素            插入点/删除点          末尾元素</span><br><span class="line">       有效          ｜｜         无效</span><br><span class="line">c、insert来说，如果引起容器扩容</span><br><span class="line">	原来容器的所有迭代器就全部失效了</span><br><span class="line">删除或者增加之后，迭代器就失效了；增加也包含扩容的情况；</span><br><span class="line">d、不同容器的迭代器是不能进行比较运算的</span><br><span class="line"></span><br><span class="line">2、迭代器失效之后，问题怎么解决？</span><br><span class="line">对插入点/删除点的迭代器进行更新操作</span><br><span class="line">*/</span><br><span class="line">// 删除操作</span><br><span class="line">while (it != vec.end()) &#123;</span><br><span class="line">    if (*it % 2 == 0) &#123;</span><br><span class="line">    	it = vec.erase(it);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入操作</span><br><span class="line">auto it = vec.begin();</span><br><span class="line">for (; it != vec.end(); ++it) &#123;</span><br><span class="line">    if (*it % 2 == 0) &#123;</span><br><span class="line">        it = vec.insert(it, *it -1);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 容器底层迭代器失效的实现方式</span><br><span class="line">// 多看看代码</span><br></pre></td></tr></table></figure>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><p><img src="new_delete.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">1、malloc和new的区别？</span><br><span class="line">	malloc是按照字节分配内存的；new开辟内存时需要指定类型 new int[10]，</span><br><span class="line">所以malloc开辟内存返回的是void*，operator new 返回的是特定类型</span><br><span class="line">	malloc只负责开辟空间，new不仅仅是开辟空间，还可以进行数据的初始化，调用构造函数；new int（20） new int【20】（）；</span><br><span class="line">	malloc开辟内存失败时返回nullptr，new开辟失败时抛出bad_alloc异常</span><br><span class="line">2、free和delete的区别？</span><br><span class="line">delete （int*）p；调用析构函数之后free（p）</span><br><span class="line">new -》 operator new</span><br><span class="line">delete -》 operator delete</span><br><span class="line">3、new和delete单个和数组形式能够混用吗？C++为什么要区分单个和数组的形式？</span><br><span class="line">	对于普通的内置类型，混用是没有问题的；</span><br><span class="line">	对于自定义的类型，因为有析构函数，因此为了正确的调用析构函数，在开辟对象数组的时候，会多开辟4个字节，记录对象的个数</span><br><span class="line">	如上图所示，operator分配内存时分配的是0x100，但是返回的地址是0x104；如果不匹配的话就会出错；</span><br><span class="line">*/</span><br><span class="line">// 先调用operator new开辟内存空间，然后调用对象的构造函数（初始化）</span><br><span class="line">void* operator new(size_t size) &#123;</span><br><span class="line">    void *p = malloc(size);</span><br><span class="line">    if (p == nullptr) &#123;</span><br><span class="line">        throw bad_alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">// delete p; 调用p指向对象的析构函数，再调用operator delete释放空间</span><br><span class="line">void operator delete(void *ptr) &#123;</span><br><span class="line">    free(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="new和delete实现的对象池应用"><a href="#new和delete实现的对象池应用" class="headerlink" title="new和delete实现的对象池应用"></a>new和delete实现的对象池应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="第六章-OOP"><a href="#第六章-OOP" class="headerlink" title="第六章 OOP"></a>第六章 OOP</h1><h2 id="继承的本质和原理"><a href="#继承的本质和原理" class="headerlink" title="继承的本质和原理"></a>继承的本质和原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、继承的本质和原理</span><br><span class="line">	a、代码的复用</span><br><span class="line">2、类和类之间的关系</span><br><span class="line">	组合：a part of 一部分的关系</span><br><span class="line">	继承：a kind of 一种的关系			</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>继承方式</th>
<th>基类的访问限定符</th>
<th>派生类的访问限定符</th>
<th>外部的访问限定符</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>public</td>
<td>public</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td>protected</td>
<td>protected</td>
<td>N</td>
</tr>
<tr>
<td></td>
<td>private</td>
<td>不可见</td>
<td>N</td>
</tr>
<tr>
<td>protected</td>
<td>public</td>
<td>protected</td>
<td>N</td>
</tr>
<tr>
<td></td>
<td>protected</td>
<td>protected</td>
<td>N</td>
</tr>
<tr>
<td></td>
<td>private</td>
<td>不可见</td>
<td>N</td>
</tr>
<tr>
<td>private</td>
<td>public</td>
<td>private</td>
<td>N</td>
</tr>
<tr>
<td></td>
<td>protected</td>
<td>private</td>
<td>N</td>
</tr>
<tr>
<td></td>
<td>private</td>
<td>不可见</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">	外部对象只能够访问public的成员，protected和private的成员无法直接访问；</span><br><span class="line">	在继承结构中，派生类可以从基类中继承private的成员，但是无法直接访问，因此应该认为是不可见的</span><br><span class="line">	protected和private的区别？</span><br><span class="line">		在基类中定义的成员，想要被派生类访问，但是不想被外部访问，就可以定义为protected；如果都不想被访问，就定义在private</span><br><span class="line">	默认的继承方式是什么？</span><br><span class="line">		要看派生类是class定义的还是struct定义的，class默认为private继承；struct默认为public继承</span><br></pre></td></tr></table></figure>
<h2 id="派生类的构造过程"><a href="#派生类的构造过程" class="headerlink" title="派生类的构造过程"></a>派生类的构造过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、派生类从继承可以继承基类的所有成员和函数</span><br><span class="line">派生类如何初始化从基类继承过来的成员呢？</span><br><span class="line">	通过调用基类的构造方法来进行初始化</span><br><span class="line">派生类的构造函数和析构函数，用来构造和析构派生类部分；</span><br><span class="line">基类的构造函数和析构函数，用来构造和析构基类部分；</span><br><span class="line">派生类构造和析构的过程是：</span><br><span class="line">	派生类调用基类的构造函数，初始化从基类继承的成员；之后调用派生类的构造函数，初始化派生类的成员</span><br><span class="line">	调用派生类的析构函数，释放派生类的资源；之后调用基类的析构函数，释放基类的资源</span><br></pre></td></tr></table></figure>
<h2 id="重载、覆盖、隐藏"><a href="#重载、覆盖、隐藏" class="headerlink" title="重载、覆盖、隐藏"></a>重载、覆盖、隐藏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、重载关系</span><br><span class="line">	一组函数，函数名相同，参数列表不同；最重要的是必须处于同一作用域内</span><br><span class="line">2、隐藏关系</span><br><span class="line">	在继承结构中，派生类的同名成员，将基类的同名成员给隐藏掉了</span><br><span class="line">	想要调用的话必须显示的调用；</span><br><span class="line">=============================================================</span><br><span class="line">1、把继承结构，也说成从上到下的结构</span><br><span class="line">2、基类对象 和 派生类对象的相互转化？</span><br><span class="line">3、基类指针和派生类指针的相互指向？</span><br><span class="line">总结：在继承结构中，只支持从下到上的类型转换；</span><br><span class="line">派生类对象赋值给基类对象，会做对象的切割；</span><br><span class="line">基类指针指向派生类，指针不会越界，反之，派生类指针会指向未定义区域</span><br></pre></td></tr></table></figure>
<h2 id="虚函数、静态绑定、动态绑定"><a href="#虚函数、静态绑定、动态绑定" class="headerlink" title="虚函数、静态绑定、动态绑定"></a>虚函数、静态绑定、动态绑定</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">静态绑定：编译时期的绑定；</span><br><span class="line">覆盖：</span><br><span class="line">基类和派生类的方法、返回值、函数名和形参列表都相同，而且基类的方法是虚函数，那么派生类的方法就自动处理成虚函数，它们之间为覆盖关系。</span><br><span class="line">一个类添加了虚函数，对这个类有什么影响？</span><br><span class="line">总结：</span><br><span class="line">	如果类中定义了虚函数，那么编译阶段，编译器会给这个类产生一个唯一的vftable虚函数表，虚函数表中记录了RTTI指针和虚函数的地址。当程序运行时，虚函数表会被加载到.rodata区域；</span><br><span class="line">	一个类里面定义了函数，那么这个类定义的对象，其运行时，内存中开始部分，多存储一个vfptr的虚函数指针，指向相应类型的虚函数表vftable。一个类型定义的n个对象，他们的vfptr指向的都是同一张虚函数表</span><br><span class="line">	一个类里面虚函数的个数，不影响对象内存大小（vfptr），影响的是虚函数表的大小</span><br><span class="line">编译器进行编译的过程中，如果发现函数是普通函数，那么直接按照静态绑定的方式执行；</span><br><span class="line">如果发现函数是虚函数，那么就需要按照动态绑定来处理了。动态绑定时需要将函数中的前四个字节存储的vfptr取出来，去寻找给定的函数。</span><br></pre></td></tr></table></figure>
<h2 id="虚函数和动态绑定问题"><a href="#虚函数和动态绑定问题" class="headerlink" title="虚函数和动态绑定问题"></a>虚函数和动态绑定问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">是不是虚函数的调用就一定是动态绑定？</span><br><span class="line">	不是的，在构造函数中的函数调用一定是静态绑定；因为这个时候还没有派生类，无法进行动态绑定；</span><br><span class="line">	另外，如果不是通过指针或者引用来调用函数，那么就执行静态绑定；</span><br><span class="line">// 虚函数与静态绑定</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Base(int data = 10)</span><br><span class="line">        : m_data(data) &#123;&#125;</span><br><span class="line">    virtual void show() &#123;cout &lt;&lt; &quot;Base::show()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">private:</span><br><span class="line">    int m_data;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derive(int data = 22)</span><br><span class="line">        : Base(data), m_b(data) &#123;&#125;</span><br><span class="line">    void show() &#123;cout &lt;&lt; &quot;Derive::show()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">private:</span><br><span class="line">    int m_b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derive d;</span><br><span class="line">    // 静态绑定 用对象本身调用函数</span><br><span class="line">    b.show();</span><br><span class="line">    d.show();</span><br><span class="line"></span><br><span class="line">    // 动态绑定 必须由指针调用函数</span><br><span class="line">    Base *pb1 = &amp;b;</span><br><span class="line">    pb1-&gt;show();</span><br><span class="line">    Base *pb2 = &amp;d;</span><br><span class="line">    pb2-&gt;show();</span><br><span class="line"></span><br><span class="line">    // 动态绑定 必须由引用调用函数</span><br><span class="line">    Base &amp;rb1 = b;</span><br><span class="line">    rb1.show();</span><br><span class="line">    Base &amp;rb2 = d;</span><br><span class="line">    rb2.show();</span><br><span class="line"></span><br><span class="line">    // 动态绑定</span><br><span class="line">    Derive *pd1 = &amp;d;</span><br><span class="line">    pd1-&gt;show();</span><br><span class="line">    Derive &amp;rd1 = d;</span><br><span class="line">    rd1.show();</span><br><span class="line"></span><br><span class="line">    // 动态绑定 是不安全的</span><br><span class="line">    Derive *pd2 = (Derive *) &amp;b;</span><br><span class="line">    pd2-&gt;show();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">哪些函数不能实现成虚函数？</span><br><span class="line">	虚函数依赖：</span><br><span class="line">		虚函数能产生地址，储存在vftable中</span><br><span class="line">		因此对象必须存在</span><br><span class="line">	构造函数：</span><br><span class="line">		这时候还没有对象，因此不能是虚函数；</span><br><span class="line">		并且构造函数中即使调用虚函数，也是执行的静态绑定，因为这时候还没有派生类呢</span><br><span class="line">	static 成员方法：</span><br><span class="line">		不依赖于对象，因此不能是虚函数；</span><br><span class="line">	析构函数：</span><br><span class="line">		这时候是有对象存在的，因此可以是虚函数</span><br><span class="line">什么时候析构函数必须实现成虚函数？</span><br><span class="line">	基类的指针指向堆上new出来的子类的时候。这个时候如果基类析构函数不是虚函数的话，那么在delete p的时候只会执行基类的析构函数；派生类的析构函数不会执行，导致派生类申请的资源无法释放；基类的析构函数为虚函数的话，派生类的析构函数也为虚函数；（理论上可以将基类和派生类的析构函数看成是覆盖的关系）</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h2 id="如何理解多态"><a href="#如何理解多态" class="headerlink" title="如何理解多态"></a>如何理解多态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如何理解多态？</span><br><span class="line">	静态（编译时期）多态：</span><br><span class="line">		函数重载、模板</span><br><span class="line">	动态多态：</span><br><span class="line">		在继承结构中，基类指针指向派生类对象，通过该指针调用同名覆盖方法（虚函数）</span><br><span class="line">		多态底层是通过动态绑定实现的；pbase指向哪个派生类对象，就会访问哪个派生类的vfptr，就会访问vftable，找到对应的函数</span><br><span class="line">继承的好处？</span><br><span class="line">	代码复用</span><br><span class="line">	在基类中，提供统一的虚函数接口，让派生类进行重写；</span><br></pre></td></tr></table></figure>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">抽象类和普通类有什么区别？</span><br><span class="line">一般把什么类定义为抽象类？</span><br><span class="line">	拥有纯虚函数的类叫做抽象类；抽象类是不能实例化对象的；但是可以定义指针和变量；</span><br><span class="line">	一般将提供统一API接口的类定义为抽象类；</span><br></pre></td></tr></table></figure>
<h2 id="面试题分析"><a href="#面试题分析" class="headerlink" title="面试题分析"></a>面试题分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">问题1 下列代码的输出是？</span><br><span class="line">class Animal&#123;</span><br><span class="line">public:</span><br><span class="line">    Animal(string name)</span><br><span class="line">        : m_name(name) &#123;&#125;</span><br><span class="line">    virtual void bark() = 0;</span><br><span class="line">private:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog : public Animal&#123;</span><br><span class="line">public:</span><br><span class="line">    Dog(string name)</span><br><span class="line">        : Animal(name) &#123;&#125;</span><br><span class="line">    void bark() &#123;cout &lt;&lt; &quot;wangwangwang&quot; &lt;&lt; endl;&#125;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat : public Animal&#123;</span><br><span class="line">public:</span><br><span class="line">    Cat(string name)</span><br><span class="line">       : Animal(name) &#123;&#125;</span><br><span class="line">    void bark() &#123;cout &lt;&lt; &quot;miaomiaomiao&quot; &lt;&lt; endl;&#125;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Animal *md = new Dog(&quot;dog&quot;);</span><br><span class="line">    Animal *mc = new Cat(&quot;cat&quot;);</span><br><span class="line"></span><br><span class="line">    int *p1 = (int*)md;</span><br><span class="line">    int *p2 = (int*)mc;</span><br><span class="line">    int tmp = p1[0];</span><br><span class="line">    p1[0] = p2[0];</span><br><span class="line">    p2[0] = tmp;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;dog: &quot;;</span><br><span class="line">    md-&gt;bark();</span><br><span class="line">    cout &lt;&lt; &quot;cat: &quot;;</span><br><span class="line">    mc-&gt;bark();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">dog: miaomiaomiao</span><br><span class="line">cat: wangwangwang</span><br><span class="line">比较简单，相当于就是把两个派生类的vfptr交换了，因此调用的虚函数也就换了</span><br><span class="line">*/</span><br><span class="line">问题2:函数的默认参数问题？</span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void show(int data = 10) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base::show(): &quot; &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    void show(int data = 20) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derive::show(): &quot; &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *b = new Derive;</span><br><span class="line">    /*</span><br><span class="line">    push 0AH =&gt; 函数调用，参数压栈实在编译时期就确定好的</span><br><span class="line">    mov eax, dword ptr[b]</span><br><span class="line">    mov ecx, dword ptr[eax]</span><br><span class="line">    call ecx</span><br><span class="line">    */</span><br><span class="line">    b-&gt;show(); // 动态绑定，但是参数在编译时期就确定了；因此打印为10</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// Derive::show(): 10</span><br><span class="line">问题3:权限限定符的作用？</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void show() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base::show()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base &#123;</span><br><span class="line">private:</span><br><span class="line">    void show() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derive::show()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base *p = new Derive();</span><br><span class="line">    /*</span><br><span class="line">    成员方法能不能调用，就是说方法的访问权限是不是public的，是在编译阶段就需要确定的</span><br><span class="line">    编译阶段是base调用show，是没问题的；</span><br><span class="line">    但是在运行阶段，调用的就不是基类的show方法了；</span><br><span class="line">    将基类和派生类的访问权限对换，就会出错了；</span><br><span class="line">    */</span><br><span class="line">    p-&gt;show();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 如上述代码，虽然derive类的show方法是private的</span><br></pre></td></tr></table></figure>
<h2 id="虚基类和虚继承"><a href="#虚基类和虚继承" class="headerlink" title="虚基类和虚继承"></a>虚基类和虚继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抽象类：有virtual函数的类叫做抽象类 vfptr vftable</span><br><span class="line">虚基类：被虚继承的类叫做虚基类 vbptr vbtable （vbtable中存储的是成员变量内存的offset）</span><br></pre></td></tr></table></figure>
<p>image](memory_layout.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">派生类的内存布局就是将原有基类的成员移动到派生类成员的下方，然后在原有位置添加vbptr指针，指向vbtable表</span><br></pre></td></tr></table></figure>
<h1 id="第七章-C-STL"><a href="#第七章-C-STL" class="headerlink" title="第七章 C++ STL"></a>第七章 C++ STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">vector: 向量容器</span><br><span class="line">底层数据结构：动态开辟的数组，每次以原来空间大小的2倍进行扩容</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">增加：</span><br><span class="line">vec.push_back(20); // 末尾增加元素O（1）， 最后添加时会导致容器扩容</span><br><span class="line">vec.insert(it, 20); // 使用迭代器，插入it指向的位置O（n）</span><br><span class="line">删除：</span><br><span class="line">vec.pop_back(); // 删除末尾元素O（1）</span><br><span class="line">vec.erase(it); // 删除迭代器指向it指向的元素O（n）</span><br><span class="line">查询：</span><br><span class="line">operator[] 下标的随机访问vec[5] O(1)</span><br><span class="line">iterator 迭代器遍历</span><br><span class="line">find for_each</span><br><span class="line">foreach本质上还是通过迭代器来实现的</span><br><span class="line">注意：对容器进行连续插入或者删除操作（insert/earse），一定要更新迭代器，否则，当第一次insert或者erase完成，迭代器就已经失效了</span><br><span class="line">常用方法介绍：</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">reserve(20); // vector预留空间。只给容器底层开辟指定大小的内存空间，并不会添加新的元素</span><br><span class="line">resize()； // vector扩容用的，不仅给容器底层开辟指定大小的内存空间，还会添加新的元素</span><br><span class="line">swap()；// 两个容器进行元素交换</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    vec.reserve(20); // 只开辟空间，并不添加元素</span><br><span class="line">//    vec.resize(20); // 开辟空间，并添加元素用的时new int()</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; vec.empty() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 20; ++i) &#123;</span><br><span class="line">        vec.push_back(rand() % 100 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; vec.empty() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vec.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    int size = vec.size();</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    auto it2 = vec.begin();</span><br><span class="line">    while (it2 != vec.end()) &#123;</span><br><span class="line">        if (*it2 % 2 == 0) &#123;</span><br><span class="line">            it2 = vec.erase(it2);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ++it2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto it1 = vec.begin();</span><br><span class="line">    for (; it1 != vec.end(); ++it1) &#123;</span><br><span class="line">        cout &lt;&lt; *it1 &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for (it1 = vec.begin(); it1 != vec.end(); ++it1) &#123;</span><br><span class="line">        if (*it1 % 2 != 0) &#123;</span><br><span class="line">            it1 = vec.insert(it1, *it1 - 1);</span><br><span class="line">            it1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto i : vec) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="dequeue和list"><a href="#dequeue和list" class="headerlink" title="dequeue和list"></a>dequeue和list</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">dequeue：双端队列</span><br><span class="line">底层数据结构：动态开辟的二维数组，一维数组从2开始，以两倍的方式进行扩容，每次扩容之后，原来第二维的数组，从新的第一维数组的下标old_size/2开始存放，上下都预留相同的空行，方便支持dequeue的首尾元素添加</span><br><span class="line">deque&lt;int&gt; deq;</span><br><span class="line">增加：</span><br><span class="line">deq.push_back(20); 从末尾添加元素 O(1)  </span><br><span class="line">deq.push_front(20); 从首部添加元素 O(1)   // vec.insert(vec.begin(), 20) O(n)</span><br><span class="line">deq.insert(it, 20); it指向的位置添加元素 O(n)</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">deq.pop_back(); 从末尾删除元素 O(1)  </span><br><span class="line">deq.pop_front(); 从首部删除元素 O(1)  </span><br><span class="line">deq.erase(it);  从it指向的位置删除元素 O(n)</span><br><span class="line"></span><br><span class="line">查询搜索：</span><br><span class="line">iterator(连续的insert和erase一定要考虑迭代器失效的问题)</span><br><span class="line"></span><br><span class="line">list：链表容器</span><br><span class="line">底层数据结构：双向的循环链表   pre data next</span><br><span class="line">list&lt;int&gt; mylist;</span><br><span class="line">增加：</span><br><span class="line">mylist.push_back(20); 从末尾添加元素 O(1)</span><br><span class="line">mylist.push_front(20); 从首部添加元素 O(1)   // vec.insert(vec.begin(), 20) O(n)</span><br><span class="line">mylist.insert(it, 20); it指向的位置添加元素 O(1) // 链表中进行insert的时候，先要进行一个query查询操作</span><br><span class="line">    对于链表来说，查询操作效率就比较慢了</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">mylist.pop_back(); 从末尾删除元素 O(1)</span><br><span class="line">mylist.pop_front(); 从首部删除元素 O(1)</span><br><span class="line">mylist.erase(it);  从it指向的位置删除元素 O(1)</span><br><span class="line"></span><br><span class="line">查询搜索：</span><br><span class="line">iterator(连续的insert和erase一定要考虑迭代器失效的问题)</span><br><span class="line"></span><br><span class="line">deque和list，比vector容器多出来的增加删除函数接口：</span><br><span class="line">push_front和pop_front</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="vector和dequeue对比"><a href="#vector和dequeue对比" class="headerlink" title="vector和dequeue对比"></a>vector和dequeue对比</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">vector特点：动态数组，内存是连续的，2倍的方式进行扩容， vector&lt;int&gt; vec; 0-1-2-4-8... reserve(20)/resize</span><br><span class="line">deque特点：动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容的时候（第一维的数组进行2倍扩容）</span><br><span class="line">		面经问题：deque底层内存是否是连续的？   并不是  每一个第二维是连续的，</span><br><span class="line"></span><br><span class="line">容器的纵向考察：容器掌握的深度</span><br><span class="line">容器的横向考察：各个相似容器之间的对比</span><br><span class="line"></span><br><span class="line">vector和deque之间的区别？</span><br><span class="line">1.底层数据结构：</span><br><span class="line">2.前中后插入删除元素的时间复杂度： 中间和末尾 O(1)  前 deque O(1) vector O(n)</span><br><span class="line">3.对于内存的使用效率： vector 需要的内存空间必须是连续的    deque 可以分块进行数据存储，不需要内存空间必须是一片连续的</span><br><span class="line">4.在中间进行insert或者erase，vector和deque它们的效率谁能好一点(vector)？谁能差一点(deque)？  O(n)</span><br><span class="line"></span><br><span class="line">for(int i=0; i&lt;10000; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector和list之间的区别？   数组:增加删除O(n) 查询O(n) 随机访问O(1)   链表:(考虑搜索的时间)增加删除O(1)  查询O(n)</span><br><span class="line">1.底层数据结构：数组   双向循环链表</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">标准容器 - 容器适配器 =&gt; 设计模式，就叫做适配器模式</span><br><span class="line">怎么理解这个适配器？</span><br><span class="line">1.适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的</span><br><span class="line">2.没有实现自己的迭代器</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename Container=deque&lt;T&gt;&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void push(const T &amp;val) &#123; con.push_back(val); &#125;</span><br><span class="line">	void pop() &#123; con.pop_back(); &#125;</span><br><span class="line">	T top()const &#123; return con.back(); &#125;</span><br><span class="line">private:</span><br><span class="line">	Container con;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stack: push入栈  pop出栈  top查看栈顶元素  empty判断栈空  size返回元素个数 </span><br><span class="line"></span><br><span class="line">queue: push入队  pop出队  front查看队头元素 back查看队尾元素  empty判断队空   size返回元素个数</span><br><span class="line">queue =&gt; deque  为什么不依赖vector呢？？？</span><br><span class="line">stack =&gt; deque  为什么不依赖vector呢？？？</span><br><span class="line">1.vector的初始内存使用效率太低了！没有deque好  queue&lt;int&gt; stack&lt;int&gt;  vector 0-1-2-4-8 deque 4096/sizeof(int) = 1024</span><br><span class="line">2.对于queue来说，需要支持尾部插入，头部删除，O(1)  如果queue依赖vector，其出队效率很低</span><br><span class="line">3.vector需要大片的连续内存，而deque只需要分段的内存，当存储大量数据时，显然deque对于内存的利用率更好一些</span><br><span class="line"></span><br><span class="line">priority_queue: push入队  pop出队  top查看队顶元素  empty判断队空  size返回元素个数  默认：大根堆</span><br><span class="line">priority_queue =&gt; vector 为什么依赖vector？？？</span><br><span class="line">底层默认把数据组成一个大根堆结构  在一个内存连续的数组上构建一个大根堆或者小根堆的</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">容器的迭代器</span><br><span class="line">const_iterator:常量的正向迭代器  只能读，而不能写了</span><br><span class="line">iterator:普通的正向迭代器</span><br><span class="line">reverse_iterator:普通的反向迭代器</span><br><span class="line">const_reverse_iterator:常量的反向迭代器</span><br><span class="line">*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; vec;</span><br><span class="line">	for (int i = 0; i &lt; 20; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.push_back(rand() % 100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// vector&lt;int&gt;::iterator</span><br><span class="line">	// auto it1 = vec.begin(); </span><br><span class="line">	// const_iterator   &lt;=   iterator</span><br><span class="line">	/*</span><br><span class="line">	class const_iterator</span><br><span class="line">	&#123;</span><br><span class="line">	public:</span><br><span class="line">		const T&amp; operator*()&#123;return *_ptr;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	class iterator : public const_iterator</span><br><span class="line">	&#123;</span><br><span class="line">		T&amp; operator*()&#123;return *_ptr;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line">	vector&lt;int&gt;::const_iterator it1 = vec.begin();</span><br><span class="line">	for (; it1 != vec.end(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	// rbegin()：返回的是最后一个元素的反向迭代器表示</span><br><span class="line">	// rend：返回的是首元素前驱位置的迭代器的表示</span><br><span class="line">	// vector&lt;int&gt;::reverse_iterator</span><br><span class="line">	vector&lt;int&gt;::const_reverse_iterator rit = vec.rbegin();</span><br><span class="line">	for (; rit != vec.rend(); ++rit)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *rit &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	/*for (int v : vec)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">函数对象  =&gt;  C语言里面的函数指针</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 使用C的函数指针解决方案</span><br><span class="line">/*</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline bool mygreater(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline bool myless(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	return a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1.通过函数对象调用operator()，可以省略函数的调用开销，比通过函数指针</span><br><span class="line">调用函数（不能够inline内联调用）效率高</span><br><span class="line"></span><br><span class="line">2.因为函数对象是用类生成的，所以可以添加相关的成员变量，用来记录函数对象使用</span><br><span class="line">时更多的信息</span><br><span class="line">*/</span><br><span class="line">// C++函数对象的版本实现</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class mygreater</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(T a, T b) // 二元函数对象</span><br><span class="line">	&#123;</span><br><span class="line">		return a &gt; b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class myless</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(T a, T b) // 二元函数对象</span><br><span class="line">	&#123;</span><br><span class="line">		return a &lt; b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// compare是C++的库函数模板</span><br><span class="line">template&lt;typename T, typename Compare&gt;</span><br><span class="line">bool compare(T a, T b, Compare comp)</span><br><span class="line">&#123;</span><br><span class="line">	// 通过函数指针调用函数，是没有办法内联的，效率很低，因为有函数调用开销</span><br><span class="line">	return comp(a, b);  // operator()(a, b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; compare(10, 20, mygreater&lt;int&gt;()) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; compare(10, 20, myless&lt;int&gt;()) &lt;&lt; endl;</span><br><span class="line">	//cout &lt;&lt; compare(&#x27;b&#x27;, &#x27;y&#x27;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型算法和绑定器"><a href="#泛型算法和绑定器" class="headerlink" title="泛型算法和绑定器"></a>泛型算法和绑定器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">五、泛型算法 = templte + 迭代器 + 函数对象</span><br><span class="line">特点一：泛型算法的参数接收的都是迭代器</span><br><span class="line">特点二：泛型算法的参数还可以接收函数对象（C函数指针）</span><br><span class="line">sort,find,find_if,binary_search,for_each</span><br><span class="line"></span><br><span class="line">绑定器 + 二元函数对象 =》 一元函数对象</span><br><span class="line">bind1st：把二元函数对象的operator()(a, b)的第一个形参绑定起来</span><br><span class="line">bind2nd：把二元函数对象的operator()(a, b)的第二个形参绑定起来</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h1 id="第8章-面试问题"><a href="#第8章-面试问题" class="headerlink" title="第8章 面试问题"></a>第8章 面试问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.rodata是内存页面的属性；.text段是.rodata段的一部分；两者不是一个层级的东西，划分的标准都不一样；</span><br><span class="line">因为c和C++要支持可变参数，所以参数压栈顺序是从右向左压栈；</span><br><span class="line">	从右向左压的话，最后可以通过ebp+4来取得第一个参数；否则不知道要压多少个参数；</span><br><span class="line">函数参数传递是调用的拷贝构造函数</span><br><span class="line">	如果用临时对象拷贝构造新对象，那么临时对象就不会再产生了；</span><br><span class="line">	返回对象时，直接返回，不要先定义临时变量再返回；</span><br></pre></td></tr></table></figure>

    
  </div>

  
  <!-- Post Copyright -->

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/Cpp/">Cpp</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2022/05/14/Cpp%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">Cpp高级笔记</span>  
        <span class="prev-text nav-mobile">上一篇</span>  
      </a>  
      
      
      <a class="next" href="/2022/04/12/Cmake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">  
        <span class="next-text nav-default">Cmake学习笔记</span>  
        <span class="prev-text nav-mobile">下一篇</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="gitalk-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/fengxuegt" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2021 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">枫雪</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
  

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css" />


<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'Ov23linyjoE7z3V3Gako',
    clientSecret: '4bbd23045cfc104a6cf9f988ca2051cf86f1b25b',
    repo: 'blog-review',
    owner: 'fengxuegt',
    admin: ['fengxuegt'],
    id: md5(location.pathname),
    
    language: '',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  
    
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>

</html>