<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="汇编语言一" />


<!-- Website keywords -->

<meta name="keywords" content="汇编, 枫雪gt" />




<!-- Website rss -->

<link rel="alternate" href="/default" title="枫雪gt" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="http://example.com/2022/01/16/汇编语言一/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>汇编语言一 - 枫雪gt</title>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">枫雪gt</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">枫雪gt</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      汇编语言一
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2022-01-16
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/Technology/">Technology</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">汇编语言(一)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 寄存器（CPU工作原理）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 寄存器（内存访问）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">第四章 第一个汇编程序</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <p><strong>写在前面</strong><br>这篇博客是汇编语言（王爽）的学习笔记（一）</p>
<span id="more"></span>
<h1 id="汇编语言-一"><a href="#汇编语言-一" class="headerlink" title="汇编语言(一)"></a>汇编语言(一)</h1><h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【学习汇编主要是：学习汇编的编程思想，掌握机器运行的思维】</span><br><span class="line">汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。</span><br><span class="line">1.汇编课程的研究重点</span><br><span class="line">	如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作</span><br><span class="line">2.汇编语言的主体是汇编指令</span><br><span class="line">3.汇编指令和机器指令的差别在于指令的表示方法上</span><br><span class="line">	汇编指令是机器指令便于记忆的书写格式</span><br><span class="line">4.汇编语言时机器指令的助记符</span><br><span class="line">5.汇编语言的组成</span><br><span class="line">	1.汇编指令（机器码的助记符）</span><br><span class="line">	2.伪指令（由编译器执行）</span><br><span class="line">	3.其他符号（由编译器识别，如：+ - * /）</span><br><span class="line">	汇编语言的核心是汇编指令，他决定了汇编语言的特性</span><br><span class="line">6.CPU对存储器的读写</span><br><span class="line">	CPU要想进行数据的读写，必须和外部器件（即芯片）进行三类信息的交互</span><br><span class="line">	1.地址信息：存储单元的地址</span><br><span class="line">	2.控制信息：芯片的选择，读或写命令</span><br><span class="line">	3.数据信息：读或写的数据</span><br></pre></td></tr></table></figure>
<h2 id="第二章-寄存器（CPU工作原理）"><a href="#第二章-寄存器（CPU工作原理）" class="headerlink" title="第二章 寄存器（CPU工作原理）"></a>第二章 寄存器（CPU工作原理）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">CPU=运算器+控制器+【寄存器】，器件之间通过总线相连</span><br><span class="line">8086CPU有14个寄存器，名称分别为：</span><br><span class="line">	AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW	</span><br><span class="line">2.1 通用寄存器</span><br><span class="line">	1.8086CPU所有的寄存器都是16位的，可以存放2个字节</span><br><span class="line">	2.AX、BX、CX、DX通常用来存放一般性数据</span><br><span class="line">		被称为通用寄存器</span><br><span class="line">	3.8086上一代CPU中的寄存器都是8位的，为了保证兼容性</span><br><span class="line">		这四个寄存器都是可以分为2个独立的8位寄存器使用</span><br><span class="line">		AX=AH+AL</span><br><span class="line">		BX=BH+BL</span><br><span class="line">		CX=CH+CL</span><br><span class="line">		DX=DH+DL</span><br><span class="line">	4.AX的低8位（0-7）构成AL寄存器</span><br><span class="line">		高8位（8-15）构成了AH寄存器</span><br><span class="line">		AH和AL寄存器是可以独立使用的8位寄存器</span><br><span class="line">2.2 字在寄存器中的存储</span><br><span class="line">	8086一个字16位</span><br><span class="line">2.3 几条汇编指令</span><br><span class="line">	1.汇编指令不区分大小写 </span><br><span class="line">	2.几条汇编指令</span><br><span class="line">		mov ax,18	;AX=18</span><br><span class="line">		mov ah,78	;AH=78</span><br><span class="line">		add ax,8	;AX=AX+8</span><br><span class="line">		mov ax,bx	;AX=BX</span><br><span class="line">		add ax,bx	;AX+=BX</span><br><span class="line">	3.用目前学过的汇编指令，最多使用四条指令，编程计算2的4次方</span><br><span class="line">		mov ax,2	;ax=2</span><br><span class="line">		add ax,ax	;ax=4</span><br><span class="line">		add ax,ax	;ax=8</span><br><span class="line">		add ax,ax	;ax=16</span><br><span class="line">2.4 物理地址</span><br><span class="line">    1.CPU访问内存单元时，要给出内存单元的地址。</span><br><span class="line">    2.所有的内存单元够成的存储空间是一个一维的线性空间</span><br><span class="line">    3.我们将这个唯一的地址称为物理地址</span><br><span class="line">2.5 16位结构的CPU</span><br><span class="line">    16位结构描述了一个淳朴具有以下几个方面特征：</span><br><span class="line">        1.运算器一次最多可以处理16位的数据</span><br><span class="line">        2.寄存器的最大宽度为16位</span><br><span class="line">        3.寄存器和运算器之间的通路是16位的</span><br><span class="line">2.6 8086CPU给出物理地址的方法</span><br><span class="line">    1.8086有20位地址总线，可传送20位地址，实际上的寻址能力为1M</span><br><span class="line">    2.8086内部为16位结构，它只能传送16位的地址，理论上表现出的寻址能力却只有64K</span><br><span class="line">    3.问题：8086CPU如何用内部16位的数据转换成20位的地址？</span><br><span class="line">        1.8086CPU采用一种在内部用两个16位地址合成的方法，来形成20位的物理地址</span><br><span class="line">            即：段地址+偏移地址=物理地址</span><br><span class="line">        2.地址加法器合成物理地址的方法：</span><br><span class="line">            物理地址=段地址×16+偏移地址</span><br><span class="line">        3.“地址段×16”即是数据左移4位（二进制位的左移4位，十六进制的左移1位）</span><br><span class="line">            在地址加法器中，如何完成“段地址×16”？</span><br><span class="line">            二进制形式的段地址左移4位</span><br><span class="line">2.7 “段地址×16+偏移地址=物理地址”的本质含义</span><br><span class="line">    1.即可以用两个16位的二进制数来表示一个20位的二进制数</span><br><span class="line">    2.8086CPU中内部为16位结构，但地址线却是20位的，使用地址加法器可以把16位地址变成20位地址</span><br><span class="line">        具体操作就是：段地址×16+偏移地址	    </span><br><span class="line">2.8 段的概念</span><br><span class="line">    1.内存并没有分段，段的划分来自于CPU，由于8086CPU用“段地址×16+偏移地址=物理地址”</span><br><span class="line">        的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存</span><br><span class="line">    2.以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，</span><br><span class="line">        使用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元</span><br><span class="line">    3.注意</span><br><span class="line">        1.段地址必然是16的倍数，即一个段的起始地址必然是16的倍数</span><br><span class="line">        2.偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K</span><br><span class="line">        3.CPU可以用不同的段地址和偏移地址形成同一个物理地址</span><br><span class="line">2.9 段寄存器</span><br><span class="line">    1.段寄存器就是提供段地址的</span><br><span class="line">        8086CPU有4个段寄存器：</span><br><span class="line">        1.CS（code segment）</span><br><span class="line">        2.DS（data segment）</span><br><span class="line">        3.SS（stack segment）</span><br><span class="line">        4.ES（extra segment）</span><br><span class="line">    2.当8086CPU要访问内存时，有这4个段寄存器提供内存单元的段地址</span><br><span class="line">2.10 CS和IP</span><br><span class="line">    1.CS和IP时候8086CPU中最关键的寄存器</span><br><span class="line">        他们指示了CPU当前读取指令的地址。</span><br><span class="line">    2.CS和IP的含义</span><br><span class="line">        CS：代码段寄存器</span><br><span class="line">        IP：指令指针寄存器【专用寄存器】</span><br><span class="line">    3.8086CPU工作过程的简要描述</span><br><span class="line">        1.从CS:IP指向内存单元，读取指令，读取的指令进入指令缓冲器</span><br><span class="line">        2.IP=IP+所读取指令的长度，从而指向下一条指令</span><br><span class="line">        3.执行指令，转到步骤1，重复这个过程</span><br><span class="line">    4.开机时的CS和IP</span><br><span class="line">        1.在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为</span><br><span class="line">            CS=FFFFH，IP=0000H</span><br><span class="line">        2.即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行</span><br><span class="line">        3.FFFF0H单元中的指令是8086PC机开机后执行的第一条指令</span><br><span class="line">    5.修改CS、IP的指令</span><br><span class="line">        1.在CPU中，程序员能够【用指令读写】的部件只有【寄存器】，</span><br><span class="line">            程序员可以通过改变寄存器中的内容实现对CPU的控制</span><br><span class="line">        2.CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容</span><br><span class="line">            控制CPU执行目标指令</span><br><span class="line">        3.如何修改CS和IP？</span><br><span class="line">            1.通过mov改变AX等，但是不能通过mov改变CS和IP</span><br><span class="line">            2.【jmp 段地址:偏移地址】  可以用来同时修改CS和IP</span><br><span class="line">                指令中的段地址修改CS</span><br><span class="line">                偏移地址修改IP</span><br><span class="line">            3.【jmp 某一合法的寄存器】   仅修改IP的内容</span><br><span class="line">                比如：jmp ax 或者 jmp bx（类似于mov IP ax）</span><br><span class="line">            4.jmp是只具有一个操作对象的指令</span><br><span class="line">2.11 代码段</span><br><span class="line">    1.可以将长度为N（N&lt;=64KB）的一组代码，存放在一组地址连续、其实地址为16的倍数的内存单元中</span><br><span class="line">        这段内存是用来存放代码的，从而定义了一个代码段</span><br><span class="line">    2.CPU中只认被CS:IP指向的内存单元中的内容为指令</span><br><span class="line">【实验一】查看CPU和内存，用机器指令和汇编指令编程</span><br><span class="line">    1.R命令：查看、改变CPU寄存器的内容</span><br><span class="line">        r后面加寄存器的名称可以改变CPU寄存器的内容</span><br><span class="line">    2.D命令：查看内存中的内容</span><br><span class="line">    3.E命令：改写内存中的内容</span><br><span class="line">    4.U命令：将内存汇总的机器指令翻译成汇编指令</span><br><span class="line">    5.T命令：执行一条机器指令</span><br><span class="line">    6.A命令：以汇编指令的格式在内存中写入一条机器指令</span><br><span class="line">        1.debug中输入的默认是16位数</span><br><span class="line">        2.空格数量任意</span><br><span class="line">    7.按Q可以退出</span><br></pre></td></tr></table></figure>
<h2 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.1 内存中字的存储</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://fengxuegt.github.io/2022/01/16/汇编语言-一/3.1.png"><img src="https://fengxuegt.github.io/2022/01/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%B8%80/3.1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">    1.任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个存储单元</span><br><span class="line">        也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元</span><br><span class="line">    2.注意：在内存的表示中，从高到低，是从0号单元开始，然后逐渐变大，</span><br><span class="line">        即在书写时，低位写在高的地方，高位写在低的地方，</span><br><span class="line">        如上图所示：4E20H即是0号字节存储20，1号字节存储4E</span><br><span class="line">3.2 DS和[address]</span><br><span class="line">    1.8086中有一个DS寄存器，通常用来存放要访问的数据的段地址</span><br><span class="line">    2.例如：我们要读取10000H单元的内容可以用如下程序段进行：</span><br><span class="line">        mov bx,1000H</span><br><span class="line">        mov ds,bx</span><br><span class="line">        mov al,[0]</span><br><span class="line">      上面的三条指令将10000H（1000:0）中的数据读到al中</span><br><span class="line">        1.复习：已知mov指令可以完成的两种传送功能</span><br><span class="line">            1.将数据直接送入寄存器</span><br><span class="line">            2.将一个寄存器中的内容送入另一个寄存器中</span><br><span class="line">        2.除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器</span><br><span class="line">            mov指令格式：mov 寄存器名,内存单元地址</span><br><span class="line">            [...]表示一个内存单元，“[...]”中的...表示内存单元的【偏移地址】</span><br><span class="line">            执行指令时，8086CPU自动取DS中的数据为内存单元的【段地址】</span><br><span class="line">        3.如何把1000H放入DS中？</span><br><span class="line">            要通过通用寄存器把段地址传入到DS中</span><br><span class="line">            8086CPU不支持将数据直接送入段寄存器的操作，DS是一个段寄存器</span><br><span class="line">            即：mov ds,1000H  是非法的</span><br><span class="line">            数据-&gt;通用寄存器-&gt;段寄存器</span><br><span class="line">    3.写几条指令，将AL中的数据送入内存单元10000H？</span><br><span class="line">        mov bx,1000H</span><br><span class="line">        mov ds,bx</span><br><span class="line">        mov [0],al      ;al中的字节型数据送入到1000H:0中</span><br><span class="line">3.3 字的传送</span><br><span class="line">    1.8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据</span><br><span class="line">        即：一次可以传送一个字</span><br><span class="line">    2.比如</span><br><span class="line">        mov bx,1000H</span><br><span class="line">        mov ds,bx</span><br><span class="line">        mov ax,[0]      ;1000H:0处的字型数据送入ax中</span><br><span class="line">        mov [0],cx      ;cx中的16位数据送入到1000H:0中</span><br><span class="line">3.4 mov、add、sub指令</span><br><span class="line">    1.复习：已学mov指令的几个形式</span><br><span class="line">        1.mov 寄存器,数据         ;立即寻址</span><br><span class="line">        2.mov 寄存器,寄存器        ;寄存器寻址</span><br><span class="line">        3.mov 寄存器,内存单元      ;直接寻址</span><br><span class="line">        4.mov 内存单元,寄存器      ;寄存器寻址？</span><br><span class="line">        5.mov 段寄存器,寄存器      ;寄存器寻址</span><br><span class="line">        6.mov 寄存器,段寄存器      ;寄存器寻址</span><br><span class="line">    2.add、sub同mov一样，都有两个操作对象</span><br><span class="line">        1.add的用法</span><br><span class="line">            1.add 寄存器,数据      ;立即寻址</span><br><span class="line">            2.add 寄存器,寄存器    ;寄存器寻址</span><br><span class="line">            3.add 寄存器,内存单元  ;直接寻址</span><br><span class="line">            4.add 内存单元,寄存器  ;</span><br><span class="line">        2.sub的用法</span><br><span class="line">            【不带借位的减法】</span><br><span class="line">            指令格式 sub op1,op2    ;意为：op1=op1-op2</span><br><span class="line">            1.sub 寄存器,数据      ;立即寻址</span><br><span class="line">            2.sub 寄存器,寄存器    ;寄存器寻址</span><br><span class="line">            3.sub 寄存器,内存单元  ;直接寻址</span><br><span class="line">            4.sub 内存单元,寄存器  ;</span><br><span class="line">3.5 数据段</span><br><span class="line">    如何访问数据段中的数据？</span><br><span class="line">        将一段内存当作数据段，是我们在编程时的一种安排</span><br><span class="line">        具体操作：用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元</span><br><span class="line">3.6 栈</span><br><span class="line">    1.8086CPU提供相关的指令来以栈的方式访问内存空间</span><br><span class="line">        这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用</span><br><span class="line">    2.8086CPU提供入栈和出栈指令：（最基本的）</span><br><span class="line">        push（入栈）</span><br><span class="line">        pop（出栈）</span><br><span class="line">        1.push ax：将寄存器ax中的数据送入栈中</span><br><span class="line">        2.pop ax：从栈顶取出数据送入ax</span><br><span class="line">        3.8086CPU的入栈和出栈操作都是以【字（16位）】为单位进行的</span><br><span class="line">        4.pop和push可以在寄存器和内存之间传送数据</span><br><span class="line">    3.CPU如何知道一段内存空间被当做栈使用？</span><br><span class="line">        1.8086CPU中，有两个寄存器</span><br><span class="line">            1.段寄存器SS：存放栈顶的段地址</span><br><span class="line">            2.寄存器SP：存放栈顶的偏移地址【专用寄存器】</span><br><span class="line">        2.任意时刻SS:SP指向栈顶元素，当栈为空的时候，也就不存在栈顶元素</span><br><span class="line">            ss:sp也就指向栈最高地址单元的下一个单元</span><br><span class="line">    4.执行push和pop的时候，如何知道哪个单元是栈顶单元？</span><br><span class="line">        1.执行push ax时</span><br><span class="line">            1.sp=sp-2</span><br><span class="line">            2.将ax中的内容送入到ss:sp指向的内存单元</span><br><span class="line">                ss:sp此时指向新栈顶</span><br><span class="line">        2.执行pop ax时</span><br><span class="line">            1.将ss:sp指向的内存单元的内容送入到ax中</span><br><span class="line">                注意：这里取出的内容在内存中还是存在的，并没有被重置</span><br><span class="line">                    下一轮push会覆盖</span><br><span class="line">            2.sp=sp+2</span><br><span class="line">    5.如果栈是空的，sp指向哪里？</span><br><span class="line">        sp指向最高地址单元的下一个单元</span><br><span class="line">3.7 栈顶超界的问题</span><br><span class="line">    ss、sp只记录了栈顶的地址，依靠ss、sp可以保证在入栈和出栈时找到栈顶</span><br><span class="line">    可以，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？</span><br><span class="line">    1.8086CPU不保证栈的操作不会越界</span><br><span class="line">    2.当栈空的时候，再执行pop出栈 或者 当栈满的时候再使用push入栈</span><br><span class="line">        都会发生栈顶超界问题，会操作到栈以外的数据，</span><br><span class="line">        这些数据可能是其他用途的数据或者代码</span><br><span class="line">        栈顶超界是危险的！！！</span><br><span class="line">    3.8086CPU没有记录栈顶上下限的寄存器</span><br><span class="line">3.8 栈段</span><br><span class="line">    1.将一段内存当做栈段，仅仅是我们在编程时的一种安排，</span><br><span class="line">    2.ss:sp指向我们定义的栈段的栈顶；</span><br><span class="line">    3.当栈空时，sp指向最高地址的下一个单元</span><br><span class="line">    4.思考：一个栈段最大可以设为多少？</span><br><span class="line">        64KB</span><br><span class="line">    5.设栈顶的变化范围是0-FFFFH，从栈空时sp=0（最高地址单元FFFFH的下一个单元0000H）</span><br><span class="line">        一直压栈，直到栈满，sp=0；</span><br><span class="line">        如果再次压栈，栈顶将环绕，覆盖原来栈中的内容</span><br><span class="line">    6.一段内存，既可以是代码的存储空间，又可以是数据的存储空间，还可以是栈空间</span><br><span class="line">        也可以是什么都属实。</span><br><span class="line">        关键在于CPU中寄存器的设置，即：cs、ip、ss、sp、ds的设置</span><br><span class="line">        **可以通过mov直接给sp赋值【立即数寻址】，但是不能通过mov给cs、ip、ss、ds赋值</span><br><span class="line">            给cs和ip赋值需要使用jum指令</span><br><span class="line">            给ss和ds赋值需要使用mov ss或ds,寄存器   ;【寄存器寻址】</span><br><span class="line">【实验二】</span><br></pre></td></tr></table></figure>
<h2 id="第四章-第一个汇编程序"><a href="#第四章-第一个汇编程序" class="headerlink" title="第四章 第一个汇编程序"></a>第四章 第一个汇编程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">4.1 一个源程序从写出到执行的过程</span><br><span class="line">    1.一个汇编语言程序从写出到最终执行的简要过程</span><br><span class="line">        编写-&gt;编译连接-&gt;执行</span><br><span class="line">    2.对源程序进行编译连接</span><br><span class="line">        1.使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件【.obj文件】</span><br><span class="line">        2.再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件【.EXE文件】。</span><br><span class="line">    3.可执行文件包含两部分内容</span><br><span class="line">        1.程序（从源程序的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）</span><br><span class="line">        2.相关的描述信息（比如：程序有多大、要占多少内存空间等）</span><br><span class="line">    4.执行可执行文件中的程序</span><br><span class="line">        1.在操作系统（如：MSDOS）中，执行可执行文件中的程序</span><br><span class="line">        2.操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存</span><br><span class="line">            并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序</span><br><span class="line">4.2 源程序的主要结构</span><br><span class="line">    源程序由 汇编指令+伪指令+宏指令 组成</span><br><span class="line">        伪指令：编译器处理</span><br><span class="line">        汇编指令：编译为机器码	</span><br><span class="line">    1.伪指令</span><br><span class="line">        1.没有对应的机器码的指令，不能由CPU直接执行</span><br><span class="line">        2.伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作</span><br><span class="line">    2.segment和ends【定义一个段】</span><br><span class="line">        1.segment和ends是一对成对使用的伪指令</span><br><span class="line">        2.编写汇编程序【必须】使用到的指令</span><br><span class="line">        3.segment和ends的功能是定义一个段</span><br><span class="line">            segment：说明一个段开始</span><br><span class="line">            ends：说明一个段结束</span><br><span class="line">        4.一个段必须有一个名称来标识，使用格式为</span><br><span class="line">            段名 segment</span><br><span class="line">            段名 ends</span><br><span class="line">        5.一个汇编程序由多个段组成</span><br><span class="line">            这些段用来存放【代码、数据、或当作栈空间】来使用</span><br><span class="line">            一个有意义的汇编程序至少要有一个段，这个段用来存放代码。</span><br><span class="line">    3.end【真正的没了】</span><br><span class="line">        1.end是一个汇编程序的结束标记</span><br><span class="line">        2.编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译</span><br><span class="line">        3.如果程序写完了，要在结尾处加上伪指令end</span><br><span class="line">            否则，编译器无法知道程序在何处结束</span><br><span class="line">        4.【切记】不要把end和ends搞混了</span><br><span class="line">            end：汇编程序的结束标记</span><br><span class="line">            ends：与segment成对出现</span><br><span class="line">    4.assume【寄存器和段的关联假设】</span><br><span class="line">        1.它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联</span><br><span class="line">        2.通过assume说明这种关联，在需要的情况下，</span><br><span class="line">            编译程序可以将段寄存器和某一具体的段相联系</span><br><span class="line">    5.程序和源程序</span><br><span class="line">        1.我们将源程序文件中的所有内容称为【源程序】</span><br><span class="line">        2.将源程序中最终由计算机执行处理的指令或数据称为【程序】</span><br><span class="line">        3.程序最先以汇编指令的形式，存储在源程序中</span><br><span class="line">            然后经过编译、连接后转变为机器码，存储在可执行文件中</span><br><span class="line">    6.标号，标号与段名称有所区别</span><br><span class="line">        1.一个标号指代了一个地址，即是段名称。</span><br><span class="line">        2.段名称 放在segment的前面，作为一个段的名称</span><br><span class="line">            这个段的名称最终将被汇编、连接程序处理为一个段的段地址</span><br><span class="line">    7.DOS中的程序运行</span><br><span class="line">        1.DOS是一个单任务操作系统</span><br><span class="line">        2.一个程序结束后，将CPU的控制权交还给是他得以运行的程序</span><br><span class="line">            我们称这个过程为：程序返回</span><br><span class="line">    8.程序返回</span><br><span class="line">        mov ax，4c00H</span><br><span class="line">        int 21H      ;【中断机制】是DOS最伟大的机制,Windows系统上是【消息机制】</span><br><span class="line">        这两条指令所实现的功能就是程序返回</span><br><span class="line">    9.几个和结束相关的内容</span><br><span class="line">        1.段结束：伪指令</span><br><span class="line">            通知编译器一个段的结束【ends】</span><br><span class="line">        2.程序结束：伪指令</span><br><span class="line">            通知编译器程序的结束【end】</span><br><span class="line">        3.程序返回：汇编指令</span><br><span class="line">            mov ax,4c00H</span><br><span class="line">            int 21H</span><br><span class="line">    10.语法错误和逻辑错误</span><br><span class="line">        1.语法错误</span><br><span class="line">            1.程序在编译时被编译器发现的错误</span><br><span class="line">            2.容易发现</span><br><span class="line">        2.逻辑错误</span><br><span class="line">            1.在编写时不会表现出来的错误、在运行时会发生的错误</span><br><span class="line">            2.不容易发现</span><br><span class="line">4.3 以简化的方式进行汇编和连接</span><br><span class="line">    汇编使用的程序：masm.exe</span><br><span class="line">    连接使用的程序：link.exe</span><br><span class="line">    简化方式进行汇编和连接的程序：ml.exe</span><br><span class="line">4.4 汇编和连接的作用</span><br><span class="line">    连接的作用</span><br><span class="line">    1.当源程序很大时，可以将他们分成多个源程序文件夹编译</span><br><span class="line">        每个源程序编译成为目标文件后，再用连接程序将它们连接在一起，</span><br><span class="line">        生成一个可执行文件</span><br><span class="line">    2.程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起</span><br><span class="line">        生成一个可执行文件</span><br><span class="line">    3.一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接</span><br><span class="line">        用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。</span><br><span class="line">      所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用</span><br><span class="line">        连接程序对目标文件进行处理，生成可执行文件</span><br><span class="line">4.5 可执行文件中的程序装入内存并运行的原理</span><br><span class="line">    1.在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2</span><br><span class="line">        将P1从可执行文件中加载入内存，将CPU的控制权交给P1，P1才能得以运行</span><br><span class="line">    2.当P1运行完毕后，应该将CPU的控制权交还给使他得以运行的程序</span><br><span class="line">    3.操作系统的外壳</span><br><span class="line">        1.操作系统是由多个功能模块组成的庞大、复杂的软件系统</span><br><span class="line">            任何通用的操作系统，都需要提供一个称为shell（外壳）的程序，</span><br><span class="line">            用户（操作人员）使用这个程序来操作计算机系统工作</span><br><span class="line">        2.DOS中有一个程序command.com，这个程序在DOS中称为命令解释器</span><br><span class="line">            也就是DOS系统的shell</span><br><span class="line">    4.执行可执行文件1.exe时，</span><br><span class="line">      （1）什么程序将CPU的控制权交给了1.exe？</span><br><span class="line">      （2）将程序1.exe加载入内存后，如何使程序得以运行？</span><br><span class="line">      （3）1.exe程序运行结束后，返回到了哪里？</span><br><span class="line">        1.在DOS中直接执行1.exe时，是正在运行的cmd.exe将1.exe中的程序加载入内存</span><br><span class="line">        2.cmd.exe设置CPU的CS:IP指向程序的第一条指令（即，程序的入口）</span><br><span class="line">            从而使程序得以运行</span><br><span class="line">        3.程序运行结束后，返回cmd.exe中，CPU继续运行cmd.exe</span><br><span class="line">【实验三】</span><br></pre></td></tr></table></figure>

    
  </div>

  
  <!-- Post Copyright -->

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2022/01/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BA%8C/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">汇编语言二</span>  
        <span class="prev-text nav-mobile">上一篇</span>  
      </a>  
      
      
      <a class="next" href="/2021/12/26/LeetCode-Mooc-3/">  
        <span class="next-text nav-default">LeetCode_Mooc(3)</span>  
        <span class="prev-text nav-mobile">下一篇</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="gitalk-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/fengxuegt" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2021 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">枫雪</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
  

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css" />


<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'Ov23linyjoE7z3V3Gako',
    clientSecret: '4bbd23045cfc104a6cf9f988ca2051cf86f1b25b',
    repo: 'blog-review',
    owner: 'fengxuegt',
    admin: ['fengxuegt'],
    id: md5(location.pathname),
    
    language: '',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  
    
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>

</html>