<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="汇编语言二" />


<!-- Website keywords -->

<meta name="keywords" content="汇编语言, 枫雪gt" />




<!-- Website rss -->

<link rel="alternate" href="/default" title="枫雪gt" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="http://example.com/2022/01/16/汇编语言二/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>汇编语言二 - 枫雪gt</title>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">枫雪gt</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">枫雪gt</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      汇编语言二
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2022-01-16
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/Technology/">Technology</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BA%8C"><span class="toc-number">1.</span> <span class="toc-text">汇编语言(二)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-bx-%E5%92%8C-loop-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">第五章 [bx] 和 loop 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">第六章 包含多个段的程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.</span> <span class="toc-text">第七章 更加灵活的定位内存地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">第八章 数据处理的两个基本问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">第九章 转移指令的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-call-%E5%92%8C-ret-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.</span> <span class="toc-text">第十章 call 和 ret 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">第十一章 标志寄存器</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <p><strong>写在前面</strong><br>这篇博客是汇编语言（王爽）的学习笔记（二）</p>
<span id="more"></span>

<h1 id="汇编语言-二"><a href="#汇编语言-二" class="headerlink" title="汇编语言(二)"></a>汇编语言(二)</h1><h2 id="第五章-bx-和-loop-指令"><a href="#第五章-bx-和-loop-指令" class="headerlink" title="第五章 [bx] 和 loop 指令"></a>第五章 [bx] 和 loop 指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">5.1 [bx]</span><br><span class="line">    1.和[0]类似，[0]表示内存单元，它的偏移地址是0；</span><br><span class="line">    2.[bx]同样也表示一个内存单元，它的段地址在DS中</span><br><span class="line">        它的偏移地址在bx中，至于是取字还是取字节，</span><br><span class="line">        要看他放入的寄存器是8位还是16位</span><br><span class="line">    3.补充：inc指令：相当于C语言中的++运算符</span><br><span class="line">5.2 Loop指令</span><br><span class="line">    这个指令和循环有关</span><br><span class="line">    1.指令格式：loop 标号</span><br><span class="line">        CPU执行loop指令的时候，要进行两步操作</span><br><span class="line">        1.(cx)=(cx)-1;</span><br><span class="line">        2.判断cx中的值，若不为零，则转至标号处执行程序</span><br><span class="line">            若为零，则向下执行。</span><br><span class="line">    2.通常，loop指令实现循环，cx中存放循环的次数</span><br><span class="line">    3.标号</span><br><span class="line">        在汇编语言中，标号代表了一个地址，标号标识了一个地址</span><br><span class="line">    4.使用cx和loop指令相配合实现循环功能的三个要点</span><br><span class="line">        1.在cx中存放循环次数</span><br><span class="line">        2.loop指令中的标号所标识地址要在前面</span><br><span class="line">        3.要循环执行的程序段，要写在标号和loop指令的中间</span><br><span class="line">    5.用cx和loop指令相配合实现循环功能的程序框架</span><br><span class="line">        mov cx,循环次数</span><br><span class="line">      S:循环执行的程序段</span><br><span class="line">        loop s</span><br><span class="line">5.3 在Debug中跟踪供loop指令实现的循环程序</span><br><span class="line">    **注意：在汇编程序中，数据不能以字母开头，如果要输入像FFFFH这样的数</span><br><span class="line">        则要在前面添加一个0</span><br><span class="line">    在debug程序中引入G命令和P命令</span><br><span class="line">    1.G命令</span><br><span class="line">        G命令如果后面不带参数，则一直执行程序，直到程序结束</span><br><span class="line">        G命令后面如果带参数，则执行到ip为那个参数地址停止</span><br><span class="line">    2.P命令</span><br><span class="line">        T命令相当于单步进入（step into）</span><br><span class="line">        P命令相当于单步通过（step over）</span><br><span class="line">5.4 Debug和汇编编译器Masm对指令的不同处理</span><br><span class="line">    1.在debug中，可以直接用指令 mov ax,[0] 将偏移地址为0号单元的内容赋值给ax</span><br><span class="line">    2.但通过masm编译器，mov ax,[0] 会被编译成 mov ax,0</span><br><span class="line">        1.要写成这样才能实现：mov ax,ds:[0]</span><br><span class="line">        2.也可以写成这样：</span><br><span class="line">            mov bx,0</span><br><span class="line">            mov ax,[bx]  ;或者mov ax,ds:[bx]</span><br><span class="line">5.5 loop和[bx]的联合应用</span><br><span class="line">    1.计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中</span><br><span class="line">        1.注意两个问题</span><br><span class="line">            1.12个8位数据加载一起，最后的结果可能会超出8位（越界），故要用16位寄存器存放结果</span><br><span class="line">            2.将一个8位的数据加入到16位寄存器中，类型不匹配，8位的数据不能与16位相加</span><br><span class="line">        2.【解决办法】</span><br><span class="line">            把原来8位的数据，先通过通用寄存器ax，将它们转化成16位的</span><br><span class="line">        3.代码如下</span><br><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">	;指定数据段</span><br><span class="line">	mov ax,0ffffh</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	;初始化</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov dx,0</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">	;指定循环次数，12次</span><br><span class="line">	mov cx,0ch</span><br><span class="line">circ:</span><br><span class="line">	;把8位数据存入al中,即ax中存放的是[bx]转化之后的16位数据，前8位都是0</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	;进行累加</span><br><span class="line">	add dx,ax</span><br><span class="line">	;bx自增，变化内存的偏移地址</span><br><span class="line">	inc bx</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	;程序返回</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21H</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start    </span><br><span class="line">5.6 段前缀</span><br><span class="line">    1.指令“mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中</span><br><span class="line">    2.我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器</span><br><span class="line">        比如  mov ax,ds:[0]</span><br><span class="line">              mov ax,ds:[bx]</span><br><span class="line">        这里的ds就叫做【段前缀】</span><br><span class="line">5.7 一段安全的空间</span><br><span class="line">    1.8086模式中，随意向一段内存空间写入内容是很危险的</span><br><span class="line">        因为这段空间中可能存放着【重要的系统数据或代码】</span><br><span class="line">    2.在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用【0:200~0:2FF】</span><br><span class="line">        的256个字节的空间。所以，我们使用这段空间是安全的    </span><br></pre></td></tr></table></figure>

<h2 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">6.1在代码段中使用数据</span><br><span class="line">    1.dw的含义【定义字型数据：define word，16字节】</span><br><span class="line">        在数据段中使用dw定义数据，则数据在数据段中</span><br><span class="line">        在代码段中使用dw定义数据，则数据在代码段中</span><br><span class="line">        堆栈段也是一样</span><br><span class="line">    2.在程序的第一条指令前加一个标号start，并且这个标号在伪指令end后面出现</span><br><span class="line">        可以通知编译器程序在什么地方结束，并且也可以通知编译器程序的入口在哪里</span><br><span class="line">6.2在代码段中使用栈</span><br><span class="line">    **补充：如果题目要求【逆序】存放，就要想到栈（FILO）</span><br><span class="line">    使用dw向系统申请一段空间，然后把这个空间当做栈</span><br><span class="line">6.3将数据、代码、栈放入不同的段</span><br><span class="line">    1.在前面的6.1和6.2中，我们在程序中用到了数据和栈，我们在编程的时候要注意</span><br><span class="line">        何处是数据，何处是栈、何处是代码</span><br><span class="line">    2.这样做显然有两个问题</span><br><span class="line">        1.把他们放在一个段中是程序显得混乱</span><br><span class="line">        2.前面程序中处理的数据很少，用到的栈空间也小，放在一个段里面没有问题</span><br><span class="line">            但数据、栈、代码需要的空间超过64KB，就不能放在一个段中</span><br><span class="line">            (8086中一个段的容量不能大于64KB)</span><br><span class="line">    3.我们可以和定义代码段一样的方法来定义多个段</span><br><span class="line">        然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间</span><br><span class="line">    4.将数据、代码、栈放入不同的段</span><br><span class="line">        1.我们可以在源程序中为这三个段起具有含义的名称</span><br><span class="line">            用来存放数据的段，我们将其命名为“data”</span><br><span class="line">            用来存放代码的段，我们将其命名为“code”</span><br><span class="line">            用来作栈空间的段，我们将其命名为“stack”</span><br><span class="line">          但是CPU看得懂吗？【不能】</span><br><span class="line">        2.我们在源程序中用伪指令</span><br><span class="line">            “assume cs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连</span><br><span class="line">            这样做了之后，CPU是都就会将cs指向code，ds指向data，ss指向stack</span><br><span class="line">              从而按照我们的意图来处理这些段呢？【不能】</span><br><span class="line">              伪指令CPU看不懂，伪指令是给编译器看的</span><br><span class="line">        3.若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令</span><br><span class="line">            才是CPU要执行的内容</span><br><span class="line">            需在在code段中给DS，CS、SS设置相应的值才能让CPU识别出数据段、代码段、堆栈段</span><br><span class="line">            其中汇编程序开始的地方（即代码段开始的地方）由end后面的标号所指向的地方给出</span><br><span class="line">    5.assume指令不可省略，至于为什么，需要以后多多体会</span><br><span class="line">【实验五】</span><br><span class="line">    1.如果段中的数据占N个字节，则程序加载后，这段实际占有的空间为：N%16==0?N:16×(N/16+1);</span><br><span class="line">        因为一个段最小占用16字节，即有16个字节只有这个段可以访问到</span><br><span class="line">    2.在编辑源程序的时候，如果调换各个段的编写位置，最后CS、DS、SS的值会发生变化</span><br><span class="line">    3.如果去掉start，编译器会从上到下执行，如果第一个段是代码段，则可以正常运行</span><br><span class="line">        若第一个段不是代码段，则不会正常运行</span><br><span class="line">    4.代码示例1</span><br><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">data segment</span><br><span class="line">    ;8个数据</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;栈段</span><br><span class="line">stack segment</span><br><span class="line">	;8个数据</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;代码段</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	;栈空间初始化</span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,16</span><br><span class="line">	</span><br><span class="line">	;数据段初始化</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	push ds:[0];一个栈单元是一个字</span><br><span class="line">	push ds:[2]</span><br><span class="line">	;存放数据不会改变</span><br><span class="line">	pop ds:[2]</span><br><span class="line">	pop ds:[0]</span><br><span class="line">	</span><br><span class="line">	;程序返回</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end </span><br><span class="line">5.将a，b数据段中的内容分别相加，结果放入data数据段中</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">a segment</span><br><span class="line">	db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">b segment</span><br><span class="line">	db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">data segment</span><br><span class="line">	db 0,0,0,0,0,0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;代码段</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,0</span><br><span class="line">	</span><br><span class="line">	mov dx,a</span><br><span class="line">	mov ss,dx</span><br><span class="line">	</span><br><span class="line">	mov dx,b</span><br><span class="line">	mov es,dx</span><br><span class="line">	</span><br><span class="line">	mov dx,data</span><br><span class="line">	mov ds,dx</span><br><span class="line"></span><br><span class="line">	mov cx,8</span><br><span class="line">circ:</span><br><span class="line">	add al,ss:[bx]</span><br><span class="line">	add al,es:[bx]</span><br><span class="line">	mov [bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	mov al,0</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	;程序返回</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">6.将a数据段中的前8个字型数据逆序存储到b段中</span><br><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">	dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,0</span><br><span class="line">	mov ax,a</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,0</span><br><span class="line">	</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov ax,b</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,8</span><br><span class="line">circ:</span><br><span class="line">	pop [bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop circ</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start </span><br></pre></td></tr></table></figure>

<h2 id="第七章-更加灵活的定位内存地址"><a href="#第七章-更加灵活的定位内存地址" class="headerlink" title="第七章 更加灵活的定位内存地址"></a>第七章 更加灵活的定位内存地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">本章主要讲解一些更灵活的定位内存地址的方法和相关的编程方法</span><br><span class="line">7.1 and和or指令</span><br><span class="line">    1.and指令：逻辑与指令，按位进行与运算</span><br><span class="line">        1.如:mov al,01100011B</span><br><span class="line">             and al,00111011B</span><br><span class="line">          执行后：</span><br><span class="line">             al=00100011B</span><br><span class="line">        2.通过and指令可将操作对象的相应位设为0，其他位保持不变</span><br><span class="line">            例如al的第6位设为0：and al,10111111B</span><br><span class="line">            例如al的第7位设为0：and al,01111111B</span><br><span class="line">            例如al的第0位设为0：and al,11111110B</span><br><span class="line">    2.or指令，逻辑或运算，按位进行或运算</span><br><span class="line">        1.如:mov al,01100011B</span><br><span class="line">             or  al,00111011B</span><br><span class="line">          执行后：</span><br><span class="line">            al=01111011B</span><br><span class="line">        2.通过该指令可将操作对象的相应位设为1，其他位不变</span><br><span class="line">            or al,01000000B;将al的第6位设为1</span><br><span class="line">            or al,10000000B;将al的第7位设为1</span><br><span class="line">            or al,00000001B;将al的第0位设为1</span><br><span class="line">7.2 关于ASCII码</span><br><span class="line">    一种编码方案，在计算机系统中通常被采用，8位</span><br></pre></td></tr></table></figure>

<p><img src="/ASCII.png" alt="avatar"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">7.3 以字符形式给出的数据</span><br><span class="line">    1.在汇编程序中，可以使用&#x27;×××&#x27;的方式指明数据是以字符的形式给出的</span><br><span class="line">    2.编译器会将它们转化为相应的ASCII码</span><br><span class="line">    3.例如</span><br><span class="line">        1.db &#x27;unIX&#x27;   ;相当于：db 75H,6EH,49H,58H</span><br><span class="line">            &#x27;u&#x27;、&#x27;n&#x27;、&#x27;I&#x27;、&#x27;X&#x27;的ASCII码分别为75H,6EH,49H,58H</span><br><span class="line">        2.mov al,&#x27;a&#x27;  ;相当于：mov al，61H</span><br><span class="line">            &#x27;a&#x27;的ASCII码为61H</span><br><span class="line">    4.ASCII码中，大写字母和小写字母之间的规律</span><br><span class="line">        小写字母=大写字母+32</span><br><span class="line">        小写字母=大写字母+20H</span><br><span class="line">        大写字母从41H开始排，小写字母从61H开始排</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>大写</th>
<th>二进制</th>
<th>小写</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>01000001</td>
<td>a</td>
<td>01100001</td>
</tr>
<tr>
<td>B</td>
<td>01000010</td>
<td>b</td>
<td>01100010</td>
</tr>
<tr>
<td>C</td>
<td>01000011</td>
<td>c</td>
<td>01100011</td>
</tr>
<tr>
<td>D</td>
<td>01000100</td>
<td>d</td>
<td>01100100</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">7.4 大小写转换的问题</span><br><span class="line">    1.方案一：</span><br><span class="line">        1.识别出是该字节是表示一个的大写英文字符，还是小写的</span><br><span class="line">            用于条件判断的汇编程序，目前还没有学到</span><br><span class="line">        2.根据+20H 或者 -20H进行大小写转换</span><br><span class="line">    2.方案二：</span><br><span class="line">        1.若全部转化为大写，则将第5位置0</span><br><span class="line">            and al,11011111B</span><br><span class="line">        2.若全部转化为小写，则将第5位置1</span><br><span class="line">            or  al,00100000B</span><br><span class="line">7.5 [bx+常数]</span><br><span class="line">    mov ax,[bx+200]的含义：</span><br><span class="line">    1.将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个入一个子单元</span><br><span class="line">      该字单元的偏移地址为bx中的数值加上200，段地址在ds中</span><br><span class="line">    2.也可以写成</span><br><span class="line">        1.mov ax,200[bx]</span><br><span class="line">        2.mov ax,[bx].200</span><br><span class="line">7.6 用[bx+idata]的方式进行数组的处理</span><br><span class="line">    在codesg中填写代码，将datasg中定义的第一个字符串转化为大写，第二个字符串转化为小写</span><br><span class="line">      1.我们观察datasg段中的两个字符串，一个的起始地址为0，另一个的起始地址为5</span><br><span class="line">      2.我们可以将这两个字符串看作两个数组，一个从0地址开始存放，另一个从5开始存放</span><br><span class="line">      3.我们可以用[0+bx]和[5+bx]的方式在同一个循环中定位这两个字符串中的字符</span><br><span class="line">      4.注意这个数组的定位方式，对比C语言</span><br><span class="line">        C语言的数组定位方式：a[i]，b[i]，  a、b是地址常量</span><br><span class="line">        汇编语言的数组定位方式：0[bx],5[bx]</span><br><span class="line">        所以：[bx+常数]的方式为高级语言实现数组提供了便利的机制</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;MinIX&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,datasg</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,5	;做5次循环</span><br><span class="line">circ:</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	mov al,[bx+5];等价于mov al,5[bx];等价于mov al,[bx].5</span><br><span class="line">	or al,00100000b</span><br><span class="line">	mov 5[bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line">7.7 SI和DI</span><br><span class="line">    已经学过的10个寄存器：AX、BX、CX、DX、DS、CS、SS、ES、IP、SP</span><br><span class="line">    1.SI和DI是8086CPU中和bx功能相近的寄存器</span><br><span class="line">        bx不够用，所以引进了SI和DI</span><br><span class="line">    2.SI和DI（16位）不能够分成两个8位寄存器来使用【和bx的区别】</span><br><span class="line">    3.下面三组指令实现了相同的功能</span><br><span class="line">        1.mov bx,0</span><br><span class="line">          mov ax,[bx]</span><br><span class="line">        2.mov si,0</span><br><span class="line">          mov ax,[si]</span><br><span class="line">        3.mov di,0</span><br><span class="line">          mov ax,[di]</span><br><span class="line">    4.下面三组指令也实现了相同的功能</span><br><span class="line">        1.mov bx,0</span><br><span class="line">          mov ax,[bx+123]</span><br><span class="line">        2.mov si,0</span><br><span class="line">          mov ax,[si+123]</span><br><span class="line">        3.mov di,0</span><br><span class="line">          mov ax,[di+123]</span><br><span class="line">    5.用寄存器SI和DI实现将字符串&#x27;welcome to masm!&#x27;复制到它后面的数据区中</span><br><span class="line">        通常用ds:si指向要复制的源始字符串</span><br><span class="line">        通常用ds:di指向要复制的目的空间</span><br><span class="line">        **注意si、di是16位寄存器，循环中自增时，应该+2</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;welcome to masm!&#x27;</span><br><span class="line">	db &#x27;................&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,16</span><br><span class="line">	</span><br><span class="line">	mov cx,8</span><br><span class="line">circ:</span><br><span class="line">	mov ax,0[si]</span><br><span class="line">	mov [di],ax</span><br><span class="line">	inc di</span><br><span class="line">	inc di</span><br><span class="line">	inc si</span><br><span class="line">	inc si</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">7.8 [bx+si]和[bx+di]</span><br><span class="line">    1.[bx+si]和[bx+di]的含义类似，我们以[bx+si]为例进行讲解</span><br><span class="line">        [bx+si]表示一个内存单元，它的偏移地址为bx中的数值加上si中的数值</span><br><span class="line">          它的偏移地址在ds中</span><br><span class="line">    2.[bx+si]也可以写成[bx][si]</span><br><span class="line">7.9 [bx+si+常数]和[bx+di+常数]</span><br><span class="line">    1.以[bx+Si+常数]为例讲解</span><br><span class="line">        [bx+si+常量]表示一个内存单元，偏移地址为bx的值+si的值+常数</span><br><span class="line">    2.指令mov ax,[bx+si+常数]也可以写成如下形式</span><br><span class="line">        1.mov ax,200[bx+si]</span><br><span class="line">        2.mov ax,200[bx][si]</span><br><span class="line">        3.mov ax,[bx].200[si]</span><br><span class="line">7.10 不同的寻址方式的灵活应用</span><br><span class="line">    1.总结几种定位内存的方法</span><br><span class="line">        1.ds:[常数]   【直接寻址】</span><br><span class="line">            用一个常量来表示地址，可用于直接定位一个内存单元</span><br><span class="line">        2.[bx]      【寄存器间接寻址】</span><br><span class="line">            用一个寄存器的值来表示内存地址，可以间接定位一个内存单元</span><br><span class="line">        3.[bx+常数]   【？？】</span><br><span class="line">            用一节寄存器的值和常量表示内存地址，可在一个起始地址的基础上用变量间接定位一个内存单元</span><br><span class="line">        4.[bx+si]</span><br><span class="line">        5.[bx+si+常数]</span><br><span class="line">    2.编程，给定数据段data，将data段中每个单词的头一个字母改写成大写字母</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;1. file         &#x27;</span><br><span class="line">	db &#x27;2. edit         &#x27;</span><br><span class="line">	db &#x27;3. search       &#x27;</span><br><span class="line">	db &#x27;4. view         &#x27;</span><br><span class="line">	db &#x27;5. options      &#x27;</span><br><span class="line">	db &#x27;6. help         &#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,6</span><br><span class="line">circ:</span><br><span class="line">	mov al,[bx+3]</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx+3],al</span><br><span class="line">	add bx,16</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">3.编程，给定数据段data，将data段中的每个单词改为大写字母</span><br><span class="line">  1.【loop指令cx-1之后，在判断是否为0】</span><br><span class="line">  2.双重循环用汇编怎么实现？</span><br><span class="line">    应该在每次开始内循环的时候，将外层循环的cx的值保存起来，</span><br><span class="line">    在执行外层循环的loop指令前，在恢复外层循环的cx数值。</span><br><span class="line">    **可以用寄存器来临时保存，也可以用栈空间（内存）保存【没有多余的寄存器】</span><br><span class="line">        更好的方法是使用：栈</span><br><span class="line">      1.使用寄存器实现</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db 4,4,6,4,7,4;单词的字母数</span><br><span class="line">	db &#x27;          &#x27;;补齐</span><br><span class="line">	db &#x27;1. file         &#x27;</span><br><span class="line">	db &#x27;2. edit         &#x27;</span><br><span class="line">	db &#x27;3. search       &#x27;</span><br><span class="line">	db &#x27;4. view         &#x27;</span><br><span class="line">	db &#x27;5. options      &#x27;</span><br><span class="line">	db &#x27;6. help         &#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,16</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,0</span><br><span class="line">	</span><br><span class="line">	mov cx,6;外层循环6次</span><br><span class="line">outer:;外层循环</span><br><span class="line">	mov dx,cx;用寄存器将外层循环的次数保存，C语言中是用栈来保存的</span><br><span class="line">	</span><br><span class="line">	mov cx,0</span><br><span class="line">	mov cl,[di];内循环的次数	</span><br><span class="line">	inner:;内层循环</span><br><span class="line">		mov al,[bx][si+3]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx][si+3],al</span><br><span class="line">		inc si</span><br><span class="line">		loop inner</span><br><span class="line">	</span><br><span class="line">	add bx,16</span><br><span class="line">	mov si,0</span><br><span class="line">	inc di</span><br><span class="line">	mov cx,dx;恢复外层循环的次数</span><br><span class="line">	loop outer</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">2.使用栈实现【更好的方法】</span><br><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">	db 4,4,6,4,7,4;单词的字母数</span><br><span class="line">	db &#x27;          &#x27;;补齐</span><br><span class="line">	db &#x27;1. file         &#x27;</span><br><span class="line">	db &#x27;2. edit         &#x27;</span><br><span class="line">	db &#x27;3. search       &#x27;</span><br><span class="line">	db &#x27;4. view         &#x27;</span><br><span class="line">	db &#x27;5. options      &#x27;</span><br><span class="line">	db &#x27;6. help         &#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	dw 1,2,3,4,5,6,7,8</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,16</span><br><span class="line">	mov bx,16</span><br><span class="line">	mov si,0</span><br><span class="line">	</span><br><span class="line">	mov cx,6;外层循环6次</span><br><span class="line">outer:;外层循环</span><br><span class="line">	push cx;将外层循环的次数保存</span><br><span class="line">	</span><br><span class="line">	mov cx,0</span><br><span class="line">	mov cl,[di];内循环的次数	</span><br><span class="line">	inner:;内层循环</span><br><span class="line">		mov al,[bx][si+3]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx][si+3],al</span><br><span class="line">		inc si</span><br><span class="line">		loop inner</span><br><span class="line">	</span><br><span class="line">	add bx,16</span><br><span class="line">	mov si,0</span><br><span class="line">	inc di</span><br><span class="line">	pop cx;恢复外层循环的次数</span><br><span class="line">	loop outer</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">本章对前面的所有内容是具有总结性的</span><br><span class="line">计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中：</span><br><span class="line">    1.处理的数据在什么地方？</span><br><span class="line">    2.要处理的数据有多长？</span><br><span class="line">  这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作</span><br><span class="line">8.1 bx、si、di、bp</span><br><span class="line">    1.在8086CPU中，只有这4个寄存器（bx、bp、si、di）可以用在“[...]”</span><br><span class="line">        中，用来进行内存单元的寻址</span><br><span class="line">    2.在“[...]”中，这四个寄存器（bx、bp、si、di）可以单个出现，</span><br><span class="line">        或者只能以以下4种组合出现</span><br><span class="line">        1.bx和si</span><br><span class="line">        2.bx和di</span><br><span class="line">        3.bp和si</span><br><span class="line">        4.bp和di</span><br><span class="line">    3.错误的用法</span><br><span class="line">        mov ax,[bx+bp]</span><br><span class="line">        mov ax,[si+di]</span><br><span class="line">    4.只要在[...]中使用寄存器bp，则指令中没有显性给出段地址，那么</span><br><span class="line">        段地址就默认在ss中，比如：</span><br><span class="line">        mov ax,[bp]       ax的值为栈空间中，偏移地址为bp的内存单元</span><br><span class="line">        mov ax,[bp+常数]      </span><br><span class="line">        mov ax,[bp+si]</span><br><span class="line">        mov ax,[bp+si+常数]</span><br><span class="line">8.2 机器指令处理的数据所在的位置</span><br><span class="line">    1.绝大部分机器指令进行数据处理的指令大致可分为3大类</span><br><span class="line">        读取、写入、运算</span><br><span class="line">    2.在机器指令这一层，并不关心数据的值是多少，而关心指令执行前一刻</span><br><span class="line">        它将要处理的数据所在的位置</span><br><span class="line">    3.指令在执行前，所要处理的数据可以在三个地方</span><br><span class="line">        CPU内部（寄存器）、内存、端口</span><br><span class="line">8.3 汇编语言中数据位置的表达</span><br><span class="line">    汇编语言中用三个概念来表达数据的位置</span><br><span class="line">      1.立即数</span><br><span class="line">      2.寄存器</span><br><span class="line">      3.段地址（SA）和偏移地址（EA）</span><br><span class="line">        1.存放段地址的寄存器可以是默认的，</span><br><span class="line">            既可以是默认在ds中，也可以是在ss中（使用bp寄存器）</span><br><span class="line">        2.存放段地址的寄存器也可以显性的给出</span><br><span class="line">            mov ax,ds:[bp]</span><br><span class="line">            mov ax,es:[bx]</span><br><span class="line">            mov ax,ss:[bx+si]</span><br><span class="line">            mov ax,cs:[bx+si+8]</span><br><span class="line">8.4 寻址方式</span><br></pre></td></tr></table></figure>

<p><img src="/8.1.png" alt="avatar"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">8.5 指令要处理的数据有多长？</span><br><span class="line">    1.8086CPU的指令，可以处理两种尺寸的数据，byte和word</span><br><span class="line">        所以在机器指令中要指明，指令进行的是字操作还是字节操作</span><br><span class="line">    2.8086CPU确定数据长度的几种方法</span><br><span class="line">        1.通过寄存器名指明要处理的数据的尺寸</span><br><span class="line">            mov al,1        ;指明数据是字节型的</span><br><span class="line">            mov bx,ds:[0]   ;指明数据是字型的</span><br><span class="line">        2.在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度</span><br><span class="line">            X在汇编指令中可以为word或byte</span><br><span class="line">            1.下面的指令中，用byte ptr指明了指令访问的内存单元是字节型单元</span><br><span class="line">              mov byte ptr ds:[0],1</span><br><span class="line">              inc byte ptr [bx]</span><br><span class="line">              inc byte ptr ds:[0]</span><br><span class="line">              add byte ptr [bx],2</span><br><span class="line">            2.下面的指令中，用word ptr指明了指令访问的内存单元是字型单元</span><br><span class="line">              mov word ptr ds:[0],1</span><br><span class="line">              inc word ptr [bx]</span><br><span class="line">              inc word ptr ds:[0]</span><br><span class="line">              add word ptr [bx],2</span><br><span class="line">        3.其他方法</span><br><span class="line">            有些指令默认了访问的内存单元类型</span><br><span class="line">            pop、push指令，一定是字型数据</span><br><span class="line">    3.在没有寄存器参与的内存单元访问指令中，用word ptr或者byte ptr</span><br><span class="line">        显性地指明所要访问的内存单元的长度，是非常有必须要的</span><br><span class="line">        否则，CPU无法得知所要访问的单元是字单元，还是字节单元</span><br><span class="line">8.6 寻址方式的综合应用</span><br><span class="line">8.7 div指令</span><br><span class="line">    1.div是除法指令（division），使用div作除法的时候，要求</span><br><span class="line">        1.除数：8位或16位，在寄存器或内存单元中</span><br><span class="line">        2.被除数：（默认）放在AX或DX和AX中</span><br><span class="line">        3.除数与被除数的相互关系</span><br><span class="line">            除数  被除数</span><br><span class="line">            8位   16位（AX）</span><br><span class="line">            16位  32位（DX+AX）</span><br><span class="line">        4.结果存放的位置</span><br><span class="line">            运算  8位  16位</span><br><span class="line">            商    AL   AX</span><br><span class="line">            余数  AH   DX</span><br><span class="line">    2.div指令格式</span><br><span class="line">        1.div 寄存器</span><br><span class="line">        2.div 内存单元</span><br><span class="line">        除数是寄存器或内存单元的内容</span><br><span class="line">    3.div指令示例</span><br><span class="line">        1.div byte ptr ds:[0]   ;被除数是16位，除数是ds:[0]的内容(8位)</span><br><span class="line">          含义：(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">               (ah)=(ax)/((ds)*16+0)的余数</span><br><span class="line">       2.div word ptr es:[0]    ;被除数是32位，除数是es:[0]的内容(16位)</span><br><span class="line">          含义：(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</span><br><span class="line">               (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数   </span><br><span class="line">    4.利用除法指令计算100001/100</span><br><span class="line">        1.被除数100001大于65535，要使用dx和ax两个寄存器联合存放</span><br><span class="line">          即说要进行的16位的除法</span><br><span class="line">        2.除数100小于255，可以在一个8位寄存器中存放，但是，因为被除数是32位</span><br><span class="line">          除数应为16位，所以要用16位寄存器来存放除法100</span><br><span class="line">        3.现将100001表示成十六进制数：186A1H，即dx中存放1H，ax中存放86A1H</span><br><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx  ;默认除数是16位的</span><br><span class="line">8.8 伪指令dd</span><br><span class="line">    1.dd是用来定义双字型数据的</span><br><span class="line">    2.示例</span><br><span class="line">        data segment</span><br><span class="line">            db 1    ;字节型数据</span><br><span class="line">            dw 1    ;字型数据</span><br><span class="line">            dd 1    ;双字型数据</span><br><span class="line">        data ends</span><br><span class="line">    3.已知data段数据，用div计算data中第一个数据除以第二个数据后的结果，</span><br><span class="line">        商存放在第3个数据的内存单元中</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	dd 100001</span><br><span class="line">	dw 100</span><br><span class="line">	dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,[bx]     ;低位存放在ax中</span><br><span class="line">	mov dx,[bx+2]   ;高位存放在dx中</span><br><span class="line">	div word ptr [bx+4]</span><br><span class="line">	mov [bx+6],ax   ;商存放在ax中，把ax中的内容放入内存中</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">8.9 dup</span><br><span class="line">    1.dup是一个操作符，在汇编语言中，同db、dw、dd等一样，也是有编译器识别处理的符号</span><br><span class="line">    2.dup和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复</span><br><span class="line">    3.dup示例</span><br><span class="line">        1.db 3 dup(0)   ;定义了3个字节，他们的值都是0</span><br><span class="line">        2.db 3 dup(0,1,2)   ;定义了9个字节，他们是0、1、2、0、1、2、0、1、2</span><br><span class="line">        3.db 3 dup(&#x27;abc&#x27;,&#x27;ABC&#x27;) ;定义了18个字节，相当于db&#x27;abcABCabcABCabcABC&#x27;</span><br><span class="line">    4.dup的使用格式</span><br><span class="line">        db 重复的次数 dup(重复的字节型数据)</span><br><span class="line">        dw 重复的次数 dup(重复的字型数据)</span><br><span class="line">        dd 重复的次数 dup(重复的双字型数据)</span><br><span class="line">【实验七】</span><br><span class="line">没调试成功</span><br><span class="line">assume cs:code,ds:data,ss:stack,es:table</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	;空栈时，sp指向16</span><br><span class="line">	dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	;表示21年的21个字符串</span><br><span class="line">	;起始地址0，终止地址21*4-1：83</span><br><span class="line">	db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">	db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">	db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">	;表示21年公司总收入的21个双字型数据</span><br><span class="line">	;起始地址21*4：84，终止地址21*4+21*4-1：167</span><br><span class="line">	dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">	dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">	;表示21年公司雇员人数的21个字型数据</span><br><span class="line">	;起止地址21*8：168，终止地址21*8+21*2-1：209</span><br><span class="line">	dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">	dw 11542,14430,15257,17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">	db 21 dup(&#x27;year summ ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,table</span><br><span class="line">	mov es,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,16</span><br><span class="line">	</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,0</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov bp,0 </span><br><span class="line">	</span><br><span class="line">	mov cx,21</span><br><span class="line">outer:</span><br><span class="line"></span><br><span class="line">	push si</span><br><span class="line">	add si,si</span><br><span class="line">	mov ax,ds:[bp]</span><br><span class="line">	mov es:[bx][di],ax</span><br><span class="line">	mov ax,ds:84[bp]</span><br><span class="line">	mov es:[bx][di+5],ax</span><br><span class="line">	pop si</span><br><span class="line">	mov al,168[si]</span><br><span class="line">	mov es:[bx][di+10],al</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	push si</span><br><span class="line">	add si,si</span><br><span class="line">	mov ax,ds:[bp]</span><br><span class="line">	mov es:[bx][di],ax</span><br><span class="line">	mov ax,ds:84[bp]</span><br><span class="line">	mov es:[bx][di+5],ax</span><br><span class="line">	pop si</span><br><span class="line">	mov al,168[si]</span><br><span class="line">	mov es:[bx][di+10],al</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	</span><br><span class="line">	add bx,16</span><br><span class="line">	loop outer</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">8086CPU的转移指令分为以下几类：</span><br><span class="line">    1.无条件跳转指令（如：jmp）</span><br><span class="line">    2.条件跳转指令</span><br><span class="line">    3.循环指令（如：loop）</span><br><span class="line">    4.过程，就像C语言中的函数</span><br><span class="line">    5.中断</span><br><span class="line">9.1 操作符offset</span><br><span class="line">    操作符offset在汇编语言中由编译器处理，它的功能是取标号的偏移地址</span><br><span class="line">    如：s:mov ax,offset s</span><br><span class="line">9.2 jmp指令</span><br><span class="line">    1.无条件转移，可以只修改ip，也可以同时修改cs和ip</span><br><span class="line">        1.【jmp 段地址:偏移地址】  可以用来同时修改CS和IP</span><br><span class="line">            指令中的段地址修改CS</span><br><span class="line">            偏移地址修改IP</span><br><span class="line">            这种用法编译器不认识，只能做在debug中使用</span><br><span class="line">        2.【jmp 某一合法的寄存器】   仅修改IP的内容</span><br><span class="line">            比如：jmp ax 或者 jmp bx（类似于mov IP ax）</span><br><span class="line">    2.jmp指令要给出两种信息：</span><br><span class="line">        1.转移的目的地址</span><br><span class="line">        2.转移的距离（段间转移、段内短转移、段内近转移）</span><br><span class="line">9.3 依据位移进行转移的jmp指令</span><br><span class="line">    1.jmp short 标号【转到标号处执行指令,段内短转移】</span><br><span class="line">      此格式实现的是：段内短转移，它对ip的修改范围为-128~127</span><br><span class="line">    2.也就是说，它向前转移时可以最多越过128个字节，负数使用补码表示</span><br><span class="line">      向后转移可以最多越过127个字节</span><br><span class="line">    3.CPU不需要目的地址就可以实现对ip的修改</span><br><span class="line">        jmp指令的机器码中不包含目的地址，但是可以实现跳转</span><br><span class="line">        实现的方式，是在原地址的基础上进行一个偏移量，即位移</span><br><span class="line">    4.还有一种和指令“jmp short 标号”功能类似的指令格式：</span><br><span class="line">        jmp near ptr 标号，它实现的是段内近转移 </span><br><span class="line">        功能为：(ip)=(ip)+16位位移</span><br><span class="line">        jmp short 标号是8位的位移，而jmp near ptr 标号是16位位移</span><br><span class="line">9.4 转移的目的地址在指令中的jmp指令</span><br><span class="line">    前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前ip的转移位移</span><br><span class="line">    1.指令“jmp far ptr 标号”</span><br><span class="line">        实现的是段间转移，又称为远转移,这时机器码中应该明确给出【段地址】</span><br><span class="line">    2.指令“jmp far ptr 标号”功能如下：</span><br><span class="line">        (CS)=标号所在段的段地址</span><br><span class="line">        (IP)=标号所在段中的偏移地址</span><br><span class="line">        far ptr 指明了指令用标号的段地址和偏移地址修改cs和ip</span><br><span class="line">9.5 转移地址在寄存器中的jmp指令</span><br><span class="line">    指令格式：jmp 16位寄存器</span><br><span class="line">    功能：修改ip寄存器中的值，把16位寄存器中的值送入到ip寄存器中</span><br><span class="line">9.6 转移地址在内存中的jmp指令</span><br><span class="line">    转移地址在内存中的jmp指令有两种格式：</span><br><span class="line">    1.jmp word ptr 内存单元地址（段内转移）</span><br><span class="line">        功能：将内存中的那个字视为一个偏移地址，然后跳转到那个偏移地址</span><br><span class="line">        与【jmp 寄存器】功能相似</span><br><span class="line">        内存单元地址可用寻址方式的任意格式给出</span><br><span class="line">    2.jmp dword ptr 内存单元地址（段间转移）</span><br><span class="line">        (ip)=(内存单元地址)   ;双字中的低位字是给ip的</span><br><span class="line">        (cs)=(内存单元地址+2) ;双字中的高位字是给cs的</span><br><span class="line">        跟【jmp 段地址:偏移地址】功能类似</span><br><span class="line">        内存单元地址可用寻址方式的任意格式给出</span><br><span class="line">        **补充：不能直接向内存单元中加入立即数</span><br><span class="line">            要通过寄存器，把立即数加进去</span><br><span class="line">9.7 jcxz指令</span><br><span class="line">    1.有条件跳转指令，所有的有条件跳转指令都是短转移</span><br><span class="line">        对应的机器码中包含转移的位移，而不是目的地址。对ip的修改范围都为：-128~127</span><br><span class="line">        **另一个有条件跳转指令【loop指令】</span><br><span class="line">    2.指令格式：jcxz 标号</span><br><span class="line">        如果（cx）=0，则跳转到标号处执行</span><br><span class="line">    3.jcxz 标号 指令的操作：</span><br><span class="line">        1.当(cx)=0时，(ip)=(ip)+8位位移</span><br><span class="line">        2.当(cx)!=0时，什么也不做（程序继续向下执行）</span><br><span class="line">9.8 loop指令</span><br><span class="line">    1.循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移</span><br><span class="line">    2.指令格式：loop 标号</span><br><span class="line">    3.指令的内部操作</span><br><span class="line">        1.cx=cx-1</span><br><span class="line">        2.如果cx!=0，(ip)=(ip)+8位位移，跳转</span><br><span class="line">        3.(cx)=0，什么也不做，程序向下执行</span><br><span class="line">        cx用来控制循环的次数</span><br><span class="line">9.9 根据位移进行转移的意义</span><br><span class="line">    1.根据位移进行转移，这样设计，方便了程序段在内存中的浮动装配</span><br><span class="line">        可以实现代码的复用</span><br><span class="line">    2.如果在机器码中直接给出【段地址:偏移地址】，</span><br><span class="line">        这段程序在内存中换一个位置，则会运行不正确</span><br><span class="line">    3.段内近转移、段内短转移都是根据位移进行转移，一共有四种方式</span><br><span class="line">        1.jmp short ptr 标号</span><br><span class="line">        2.jmp near ptr 标号</span><br><span class="line">        3.jcxz 标号</span><br><span class="line">        4.loop 标号</span><br><span class="line">9.10 编译器对转移位移超界的检测</span><br><span class="line">    注意，根据位移进行转移的指令，他们的转移范围会受到限制</span><br><span class="line">    如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错</span><br><span class="line">【实验八、九】【这个实验要重点看】</span><br></pre></td></tr></table></figure>

<h2 id="第十章-call-和-ret-指令"><a href="#第十章-call-和-ret-指令" class="headerlink" title="第十章 call 和 ret 指令"></a>第十章 call 和 ret 指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">call和ret指令都是转移指令，它们都能修改ip，或同时修改cs和ip</span><br><span class="line">10.1 ret和ref</span><br><span class="line">    1.ret指令用栈中的数据，修改ip的内容，从而实现【近转移】</span><br><span class="line">        CPU执行ret指令时，进行下面两步操作：</span><br><span class="line">        1.(ip)=((ss)*16+(sp))   ;ip的值修改为栈顶的内容</span><br><span class="line">        2.(sp)=(sp)+2           ;栈顶移动</span><br><span class="line">    2.retf指令用栈中的数据，修改cs和ip的内容，从而实现【远转移】</span><br><span class="line">        CPU执行retf指令时，进行下面四步操作</span><br><span class="line">        1.(ip)=((ss)*16+(sp))   ;ip的内容修改为栈顶的内容</span><br><span class="line">        2.(sp)=(sp)+2           ;栈顶移动</span><br><span class="line">        3.(cs)=((ss)*16+(sp))   ;cs的内容修改为栈顶移动之后，栈顶的内容</span><br><span class="line">        4.(sp)=(sp)+2           ;栈顶移动</span><br><span class="line">        栈顶的两个字，低位字修改为ip，高位字修改为cs</span><br><span class="line">    3.可以看出，如果我们用汇编语法来解释ret和retf指令，则</span><br><span class="line">        1.CPU执行ret指令，相当于</span><br><span class="line">            pop ip</span><br><span class="line">        2.执行retf指令时，相当于</span><br><span class="line">            pop ip</span><br><span class="line">            pop cs</span><br><span class="line">10.2 call指令</span><br><span class="line">    1.call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：</span><br><span class="line">        1.将当前的ip或cs和ip压入栈中</span><br><span class="line">        2.转移</span><br><span class="line">    2.call指令不能实现短转移，除此之外，</span><br><span class="line">        call指令实现转移的方法和jmp指令的原理相同</span><br><span class="line">    【依据位移进行转移的call指令】</span><br><span class="line">    3.CPU执行“call 标号”这种格式的call指令时，进行如下操作：</span><br><span class="line">        1.(sp)=(sp)-2         ;栈顶移动</span><br><span class="line">        2.((ss)*16+(sp))=(ip) ;当前ip内容压栈</span><br><span class="line">        3.(ip)=(ip)+16位位移   ;跳转到标号处</span><br><span class="line">    4.call指令格式：call 标号</span><br><span class="line">        相当于执行：</span><br><span class="line">        push ip</span><br><span class="line">        jmp near ptr 标号</span><br><span class="line">10.4 转移的目的地址在指令中的call指令</span><br><span class="line">    1.指令格式：call far ptr 标号</span><br><span class="line">        实现的是段间转移</span><br><span class="line">    2.执行这种格式的call指令时CPU的操作</span><br><span class="line">        1.(sp)=(sp)-2           ;栈顶移动</span><br><span class="line">        2.((ss)×16+(sp))=(cs)   ;先把cs压栈</span><br><span class="line">        3.(sp)=(sp)-2           ;栈顶移动</span><br><span class="line">        4.((ss)×16+(sp))=(ip)   ;然后把ss压栈</span><br><span class="line">    3.CPU执行“call far ptr 标号”时，相当于进行</span><br><span class="line">        push cs</span><br><span class="line">        push ip</span><br><span class="line">        jmp far ptr 标号</span><br><span class="line">10.5 转移地址在寄存器中的call指令</span><br><span class="line">    1.指令格式：call 16位寄存器</span><br><span class="line">    2.执行这种指令时，在CPU中的操作</span><br><span class="line">        1.(sp)=(sp)-2</span><br><span class="line">        2.((ss)×16+(sp))=(ip)</span><br><span class="line">        3.(ip)=(16位寄存器)</span><br><span class="line">    3.相当于</span><br><span class="line">        push ip</span><br><span class="line">        jmp 16位寄存器</span><br><span class="line">10.6 转移地址在内存中的call指令</span><br><span class="line">    转移地址在内存中的call指令有两种格式：</span><br><span class="line">    1.call word ptr 内存单元地址</span><br><span class="line">        汇编语法解释</span><br><span class="line">          push ip</span><br><span class="line">          jmp word ptr 内存单元地址</span><br><span class="line">    2.call dword ptr 内存单元地址</span><br><span class="line">        汇编语法解释</span><br><span class="line">          push cs   ;cs存放在高位</span><br><span class="line">          push ip   ;ip存放在低位</span><br><span class="line">          jmp dword ptr 内存单元地址</span><br><span class="line">10.7 call和ret的配合使用</span><br><span class="line">10.8 mul指令</span><br><span class="line">    相乘的两个数；要么都是8位，要么都是16位</span><br><span class="line">    1.8位：AL中和8位寄存器或内存字节单元中</span><br><span class="line">        AL中的内容作为被乘数</span><br><span class="line">        结果放在AX中</span><br><span class="line">    2.16位：AX中和16位寄存器或内存字单元中</span><br><span class="line">        AX中的内容作为被乘数</span><br><span class="line">        结果放在DX（高位）和AX（低位）中。</span><br><span class="line">    3.格式如下：</span><br><span class="line">        mul 寄存器</span><br><span class="line">        mul 内存单元（byte ptr或 word ptr指明是字还是字节）</span><br><span class="line">10.9 模块化程序设计</span><br><span class="line">10.10 参数和结果传递的问题</span><br><span class="line">    【编程】计算data段中第一组数据的3次方，结果保存在后面一组dword单元中</span><br><span class="line">data sgement</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">    dd 0,0,0,0,0,0,0,0 </span><br><span class="line">data ends</span><br><span class="line">10.11 批量数据的传递</span><br><span class="line">    使用寄存器、内存、栈传递数据</span><br><span class="line">    【编程】将一个全是字母，以0结尾的字符串，转化为大写</span><br><span class="line">【实验十 编写子程序】</span><br><span class="line">    1.显示字符串</span><br><span class="line">    2.解决除法溢出问题</span><br><span class="line">    3.数值显示</span><br><span class="line">【课程设计1】</span><br></pre></td></tr></table></figure>

<h2 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW）</span><br><span class="line">本章中的标志寄存器（以下简称为flag）是我们要学习的最有一个寄存器</span><br><span class="line">flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息</span><br><span class="line">8086CPU的flag寄存器的结构：</span><br><span class="line">    1.flag的1、3、4、12、13、14、15位共7位在8086CPU中没有使用，不具有任何含义</span><br><span class="line">        而0、2、4、6、7、8、9、10、11位共9位都具有特殊的含义</span><br><span class="line">    2.示意图</span><br></pre></td></tr></table></figure>

<p><img src="/11.1.png" alt="avatar"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">11.1 ZF标志</span><br><span class="line">    1.flag的第6位是ZF，零标志位。</span><br><span class="line">        它记录相关指令执行后，</span><br><span class="line">          1.结果为0，ZF=1</span><br><span class="line">          2.结果不为0，ZF=0</span><br><span class="line">    2.示例：</span><br><span class="line">        mov ax,1</span><br><span class="line">        sub ax,1</span><br><span class="line">        指令执行后，结果为0，则ZF=1</span><br><span class="line">        mov ax，2</span><br><span class="line">        sub ax，1</span><br><span class="line">        指令执行后，结果不为0，则ZF=0</span><br><span class="line">    3.注意，在8086CPU的指令集中，有的指令的执行会影响标志寄存器</span><br><span class="line">        比如：add、sub、mul、div、inc、or、and等</span><br><span class="line">        他们大都是运算指令（逻辑运算或者算术运算）</span><br><span class="line">      有的指令的执行对标志寄存器没有影响，</span><br><span class="line">        比如：mov、push、pop等，他们大都是传送指令</span><br><span class="line">11.2 PF标志</span><br><span class="line">    flag的第2位是PF，奇偶标志位</span><br><span class="line">    它记录指令执行后，结果的所有二进制位中1的个数</span><br><span class="line">      1.为偶数，PF=1</span><br><span class="line">      2.为奇数，PF=0</span><br><span class="line">11.3 SF标志</span><br><span class="line">    1.flag的第7位是SF，符号标志位</span><br><span class="line">    2.它记录指令执行后</span><br><span class="line">      1.结果为负。sf=1</span><br><span class="line">      2.结果为正，sf=0</span><br><span class="line">      sf标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负</span><br><span class="line">        sf标志把所有数当作有符号数</span><br><span class="line">        如果把数据当作无符号数运算，sf的值则没有意义，虽然相关指令会影响它的值</span><br><span class="line">    3.也就是说，CPU在执行add等指令时，是必然要影响sf标志位的值</span><br><span class="line">        至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算    </span><br><span class="line">11.4 CF标志   </span><br><span class="line">    1.flag的第0位是CF，进位标志位</span><br><span class="line">      一般请况下，在进行无符号数运算的时候，</span><br><span class="line">        它记录了运算结果的最高有效位向更高位的进位值，</span><br><span class="line">          或从更高位的借位值</span><br><span class="line">        代表假想的更高位</span><br><span class="line">    2.CPU在运算时，不会丢弃进位值，而是记录在一个特殊的寄存器的某一位上</span><br><span class="line">        8086CPU就用flag的cf为来记录这个进位值，借位也一样</span><br><span class="line">    3.在debug中的显示</span><br></pre></td></tr></table></figure>

<p><img src="/11.2.png" alt="avatar"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    4.无符号的时候产生的结果</span><br><span class="line">11.5 OF标志</span><br><span class="line">    flag中的第11位</span><br><span class="line">    进行有符号数运算的时候，如果结果超过了机器所能表示的范围称为溢出</span><br><span class="line">    1.这里所讲的溢出，只是对有符号数运算而言</span><br><span class="line">      就像进位只是相对于无符号数而言！</span><br><span class="line">    2.一定要注意cf和of的区别</span><br><span class="line">        当需要把机器码看成有符号数则使用of</span><br><span class="line">        当需要把机器码看成无符号数则使用cf</span><br><span class="line">11.6 adc标志</span><br><span class="line">    adc是带进位的加法指令，他利用了cf上记录的进位值</span><br><span class="line">    1.格式：adc 操作对象1，操作对象2</span><br><span class="line">    2.功能：操作对象1=操作对象1+操作对象2+cf</span><br><span class="line">      比如：adc ax,bx实现的功能是：</span><br><span class="line">        (ax)=(ax)+(bx)+cf</span><br><span class="line">    3.执行adc指令的时候，加上的cf的值的含义，由adc指令前的指令决定</span><br><span class="line">        也就是说，关键在于所加上的cf值是被什么指令设置的</span><br><span class="line">    4.如果cf是被sub指令设置的，那么他的含义就是借位值</span><br><span class="line">      如果是被add指令设置的，那么它的含义就是进位值</span><br><span class="line">    5.下面的指令和add ax,bx具有相同的结果</span><br><span class="line">        add al,bl</span><br><span class="line">        adc ah,bh</span><br><span class="line">        CPU提供adc指令的目的，就是来进行加法的第二步运算的</span><br><span class="line">        adc指令和add指令相配合就可以对更大的数据进行加法运算</span><br><span class="line">    【实验：编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中】</span><br><span class="line">11.7 sbb标志</span><br><span class="line">    sbb是带借位减法指令，他利用了cf位上记录的借位值</span><br><span class="line">    1.格式：sbb 操作对象1，操作对象2</span><br><span class="line">    2.功能：操作对象1=操作对象1-操作对象2-cf</span><br><span class="line">    3.利用sbb指令，我们可以对任意大的数据进行减法运算</span><br><span class="line">    4.sbb和adc是基于相同的思想设计的两条指令，</span><br><span class="line">        在应用思路上和adc类似</span><br><span class="line">11.8 cmp标志</span><br><span class="line">    1.cmp是比较指令，功能相当于减法指令，只是不保存结果</span><br><span class="line">    2.cmp指令执行后，将对标志寄存器产生影响</span><br><span class="line">    3.其他相关指令通过识别这些被影响的标志寄存器，来得知比较结果</span><br><span class="line">    4.cmp指令格式：cmp 操作对象1,操作对象2</span><br><span class="line">    5.功能：计算操作对象1-操作对象2，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置</span><br><span class="line">    6.比如：cmp ax,ax</span><br><span class="line">        做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关位</span><br><span class="line">        指令执行后</span><br><span class="line">        zf=1    ;结果为0</span><br><span class="line">        pf=1    ;结果的1的个数为偶数</span><br><span class="line">        sf=0    ;结果为正号</span><br><span class="line">        cf=0    ;结果没有产生进位或借位</span><br><span class="line">        of=0    ;结果没有溢出</span><br><span class="line">    7.根据flag，判断cmp指令的结果（无符号数）</span><br></pre></td></tr></table></figure>

<p><img src="/11.3.png" alt="avatar"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    8.cmp既可以对无符号数进行比较，也可以对有符号数进行比较</span><br><span class="line">        cmp 操作数1,操作数2   ;操作数1、操作数2都是有符号数</span><br><span class="line">        1.of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负</span><br><span class="line">            of=0，sf=1   则 操作数1比操作数2小</span><br><span class="line">            of=0，sf=0   则 操作数1比操作数2大</span><br><span class="line">        2.of=1，说明有溢出，逻辑上真正结果的正负与实际结果的正负相反</span><br><span class="line">            of=1，sf=1   则 操作数1比操作数2大</span><br><span class="line">            of=1，sf=0   则 操作数1比操作数2小</span><br><span class="line">11.9 检测比较结果的条件转移指令</span><br><span class="line">    1.这些条件转移指令通常和cmp相配合使用</span><br><span class="line">    2.因为cmp指令可以同时进行两种比较，无符号数和有符号数的比较</span><br><span class="line">      所以，这些转移指令也分为两种，即：</span><br><span class="line">        1.根据【无符号数】的比较结果进行转移的条件转移指令，</span><br><span class="line">          他们检测zf、cf的值</span><br><span class="line">        2.根据【有符号数】的比较结果进行转移的条件转移指令</span><br><span class="line">          他们检测sf、of和zf的值</span><br><span class="line">    3.无符号比较，条件转移指令小结【无符号，6个】</span><br><span class="line">      1.je  等于则转移     zf=1</span><br><span class="line">      2.jne 不等于则转移   zf=0</span><br><span class="line">      3.jb  低于则转移     cf=1      【b表示below】</span><br><span class="line">      4.jnb 不低于则转移   cf=0</span><br><span class="line">      5.ja  高于则转移     cf=0，zf=0【a表示above】</span><br><span class="line">      6.jna 不高于则转移   cf=1或zf=1</span><br><span class="line">11.10 DF标志和串传送指令</span><br><span class="line">    1.flag的第10位DF，方向标志位</span><br><span class="line">        在串处理指令（movsb，movsw）中，控制每次操作后si、di的增减</span><br><span class="line">        df=0：每次操作后si，di递增</span><br><span class="line">        df=1：每次操作后si，di递减</span><br><span class="line">    2.格式：movsb</span><br><span class="line">    3.功能：（以字节为单位传送）</span><br><span class="line">        1.((es)*16+(di))=((ds)*16+(si))</span><br><span class="line">        2.如果df=0，则：(si)=(si)+1</span><br><span class="line">                       (di)=(di)+1</span><br><span class="line">          如果df=1，则：(si)=(si)-1</span><br><span class="line">                       (di)=(di)-1</span><br><span class="line">        3.功能文字描述</span><br><span class="line">            movsb的功能是将ds:si指向的内存单元中的字节</span><br><span class="line">            送入es:di中，然后根据标志寄存器df位的值，</span><br><span class="line">              将si和di递增或递减</span><br><span class="line">    4.movsw 传送一个字</span><br><span class="line">    5.movsb和movsw都和rep配合使用</span><br><span class="line">        格式：rep movsb</span><br><span class="line">        rep的作用根据cx的值，重复执行后面的串传送指令</span><br><span class="line">    6.cld指令和std指令</span><br><span class="line">        cld指令：将标志寄存器的df置为0【c:clear】</span><br><span class="line">        std指令：将标志寄存器的df置为1【s:set】</span><br><span class="line">11.11 pushf和popf</span><br><span class="line">    pushf：将标志寄存器的值压栈</span><br><span class="line">    popf：从栈中弹出数据，送入标志寄存器中</span><br><span class="line">    pushf和popf为直接访问标志寄存器提供了一种方法</span><br><span class="line">11.12 标志寄存器在debug中的表示</span><br></pre></td></tr></table></figure>

    
  </div>

  
  <!-- Post Copyright -->

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2022/01/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%89/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">汇编语言三</span>  
        <span class="prev-text nav-mobile">上一篇</span>  
      </a>  
      
      
      <a class="next" href="/2022/01/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80/">  
        <span class="next-text nav-default">汇编语言一</span>  
        <span class="prev-text nav-mobile">下一篇</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="gitalk-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/fengxuegt" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2021 - 2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">枫雪</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
  

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css" />


<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'Ov23linyjoE7z3V3Gako',
    clientSecret: '4bbd23045cfc104a6cf9f988ca2051cf86f1b25b',
    repo: 'blog-review',
    owner: 'fengxuegt',
    admin: ['fengxuegt'],
    id: md5(location.pathname),
    
    language: '',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  
    
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>

</html>