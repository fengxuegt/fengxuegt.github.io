<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="Cpp高级笔记" />


<!-- Website keywords -->

<meta name="keywords" content="Cpp, 枫雪gt" />




<!-- Website rss -->

<link rel="alternate" href="/default" title="枫雪gt" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="http://example.com/2022/05/14/Cpp高级笔记/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>Cpp高级笔记 - 枫雪gt</title>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">枫雪gt</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">枫雪gt</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      Cpp高级笔记
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2022-05-14
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/Technology/">Technology</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">对象调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E8%83%8C%E5%90%8E%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">对象构造背后方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">函数调用优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%9D%A1%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">三条对象优化的原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">右值引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">不带引用计数的智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-ptr"><span class="toc-number">2.1.1.</span> <span class="toc-text">auto_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scoped-ptr"><span class="toc-number">2.1.2.</span> <span class="toc-text">scoped_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">2.1.3.</span> <span class="toc-text">unique_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88shared-ptr%E3%80%81weak-ptr"><span class="toc-number">2.2.</span> <span class="toc-text">带引用计数的智能指针shared_ptr、weak_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shared-ptr%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">Shared_ptr的交叉引用问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">多线程访问共享对象的线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8deletor"><span class="toc-number">2.5.</span> <span class="toc-text">自定义删除器deletor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">绑定器和函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">问题引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">底层原理实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-11%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">c++11内容总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%BA%A7%E5%88%AB%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">C++语言级别的多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-thread-%E6%A8%A1%E6%8B%9F%E8%BD%A6%E7%AB%99%E4%B8%89%E4%B8%AA%E7%AA%97%E5%8F%A3%E5%8D%96%E7%A5%A8%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">C++ thread 模拟车站三个窗口卖票的程序</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <p><strong>写在前面</strong></p>
<p>本篇blog是学习C++过程中所记录下来的重点，便于后续回顾。笔记来自于施磊老师的C++高级视频课程；</p>
<span id="more"></span>
<h1 id="对象调用"><a href="#对象调用" class="headerlink" title="对象调用"></a>对象调用</h1><h2 id="对象构造背后方法"><a href="#对象构造背后方法" class="headerlink" title="对象构造背后方法"></a>对象构造背后方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">    Test(int a = 5, int b = 5)</span><br><span class="line">        : ma(a), mb(b) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Test(int, int)&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    ~Test() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Test(const Test &amp;t) &#123;</span><br><span class="line">        this-&gt;ma = t.ma;</span><br><span class="line">        this-&gt;mb = t.mb;</span><br><span class="line">        cout &lt;&lt; &quot;Test(const Test&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Test&amp; operator=(const Test &amp;t) &#123;</span><br><span class="line">        this-&gt;ma = t.ma;</span><br><span class="line">        this-&gt;mb = t.mb;</span><br><span class="line">        cout &lt;&lt; &quot;operator=()&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int ma;</span><br><span class="line">    int mb;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2(t1);</span><br><span class="line">    Test t3 = t1;</span><br><span class="line">    // Test(20) 显示生成临时对象 生存周期是语句</span><br><span class="line">    // C++编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了</span><br><span class="line">    Test t4 = Test(20); // Test t4(20)</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl;</span><br><span class="line">    t4 = t2; // operator=()</span><br><span class="line">    // 显示生成临时对象</span><br><span class="line">    t4 = Test(30); // 这个时候临时对象是要生成的</span><br><span class="line">    t4 = (Test)30; // 显示转换</span><br><span class="line">    </span><br><span class="line">    // 隐式生成临时对象</span><br><span class="line">    t4 = 30; // 隐式转换</span><br><span class="line">    cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl;</span><br><span class="line">    // 指针指向临时对象是错误的</span><br><span class="line">    Test *p = &amp;Test(40); // xxxx</span><br><span class="line">    // 引用指向临时对象是可以的</span><br><span class="line">    const Test &amp;ref = Test(50);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">Test t1(10, 10); // 1.Test(int, int) 全局变量首先构造</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Test t2(20, 20); // 3.Test(int, int)</span><br><span class="line">	Test t3 = t2; // 4.Test(const Test&amp;)</span><br><span class="line">	// static Test t4(30, 30); static变量第一次执行到构造</span><br><span class="line">	static Test t4 = Test(30, 30); // 5.Test(int, int) 临时变量不需要，直接构造</span><br><span class="line">	t2 = Test(40, 40); // 6.Test(int, int) operator= ~Test()</span><br><span class="line">	// (50, 50) =  (Test)50; Test(int) 逗号运算符</span><br><span class="line">	t2 = (Test)(50, 50); // 7.Test(int,int) operator=  ~Test()</span><br><span class="line">	t2 = 60; //Test(int) 8.Test(int,int) operator= ~Test()</span><br><span class="line">	Test *p1 = new Test(70, 70); // 9. Test(int,int) </span><br><span class="line">	Test *p2 = new Test[2]; // 10. Test(int,int) Test(int,int)</span><br><span class="line">	Test *p3 = &amp;Test(80, 80); // 11. Test(int,int)  ~Test()</span><br><span class="line">	const Test &amp;p4 = Test(90, 90); // 12. Test(int,int)</span><br><span class="line">	delete p1; // 13.~Test()</span><br><span class="line">	delete[]p2; // 14. ~Test() ~Test()</span><br><span class="line">&#125;</span><br><span class="line">Test t5(100, 100); // 2.Test(int, int) 全局变量首先构造</span><br></pre></td></tr></table></figure>
<h2 id="函数调用优化"><a href="#函数调用优化" class="headerlink" title="函数调用优化"></a>函数调用优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Test GetObject(Test t) &#123;</span><br><span class="line">    // 3、Test(const Test&amp;) 形参赋值</span><br><span class="line">    int val = t.getData();</span><br><span class="line">    Test tmp(val); // 4、Test(int) tmp</span><br><span class="line">    return tmp; // 5、Test(const Test&amp;) 构造临时对象main函数上栈帧</span><br><span class="line">    // 6、~Test() tmp</span><br><span class="line">    // 7、～Test() t</span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    Test t1; // 1、Test(int)</span><br><span class="line">    Test t2; // 2、Test(int)</span><br><span class="line">    t2 = GetObject(t1); // 8、operator=()</span><br><span class="line">    // 9、～Test 临时对象</span><br><span class="line">    // 10、～Test t2</span><br><span class="line">    // 11、～Test t1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三条对象优化的原则"><a href="#三条对象优化的原则" class="headerlink" title="三条对象优化的原则"></a>三条对象优化的原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1、函数参数传递过程中，对象优先按照引用传递，不要按照值传递；可以防止形参的拷贝构造</span><br><span class="line">// 2、直接返回临时对象，编译器会帮忙优化；比如省略tmp，直接返回；会在main函数栈帧上直接构造临时对象</span><br><span class="line">// 3、若使用临时对象拷贝生成同类型对象时，不再生成临时对象，而是直接构造；</span><br><span class="line">// 4、接收返回值是对象的函数调用的时候，优先使用初始化方式的方式接收，不要使用赋值的方式接收；</span><br></pre></td></tr></table></figure>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">关闭clion编译器优化：</span><br><span class="line">	在cmakelist.txt中添加 add_compile_options(-fno-elide-constructors)</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	// 右值引用</span><br><span class="line">	int a = 10;</span><br><span class="line">	int &amp;b = a; // 左值：有内存、有名字   右值：没名字（临时量）、没内存</span><br><span class="line">	//int &amp;&amp;c = a; // 无法将左值绑定到右值引用</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	int tmp = 20;</span><br><span class="line">	const int &amp;c = tmp;</span><br><span class="line">	*/</span><br><span class="line">	const int &amp;c = 20; // 不能用左值引用绑定一个右值</span><br><span class="line">	/*</span><br><span class="line">	int tmp = 20;</span><br><span class="line">	int &amp;&amp;d = tmp;</span><br><span class="line">	*/</span><br><span class="line">	int &amp;&amp;d = 20; // 可以把一个右值绑定到一个右值引用上</span><br><span class="line">	CMyString &amp;&amp;e = CMyString(&quot;aaa&quot;);</span><br><span class="line"></span><br><span class="line">	int &amp;f = d; // 一个右值引用变量，本身是一个左值</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">&amp;&amp; + &amp; = &amp;</span><br><span class="line">&amp;&amp; + &amp;&amp; = &amp;&amp;</span><br><span class="line">左值 + 右值 = 左值</span><br><span class="line">右值 + 右值 = 右值</span><br><span class="line">这是引用折叠；</span><br><span class="line">*/</span><br><span class="line">temple&lt;typename Ty&gt;</span><br><span class="line">void push_back(Ty &amp;&amp;val) &#123;</span><br><span class="line">    if (full()) &#123;</span><br><span class="line">        expand();</span><br><span class="line">    &#125;</span><br><span class="line">    _allocator.construct(_last, std::forward&lt;Ty&gt;(val));</span><br><span class="line">    _last++;</span><br><span class="line">&#125;</span><br><span class="line">// move，移动语义，得到右值类型</span><br><span class="line">// 类型完美转发，可以识别出参数究竟是左值还是右值；</span><br></pre></td></tr></table></figure>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class CSmartPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CSmartPtr(T *ptr = nullptr) :mptr(ptr) &#123;&#125;</span><br><span class="line">	~CSmartPtr() &#123; delete mptr; &#125;</span><br><span class="line">private:</span><br><span class="line">	T *mptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CSmartPtr&lt;int&gt; ptr(new int);</span><br><span class="line">	/*其它的代码...*/</span><br><span class="line">	/*由于ptr是栈上的智能指针对象，不管是函数正常执行完，还是运行过程中出现</span><br><span class="line">	异常，栈上的对象都会自动调用析构函数，在析构函数中进行了delete</span><br><span class="line">	操作，保证释放资源*/</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是一个非常简单的智能指针。主要用到了以下两点：</p>
<p>1）<strong>智能指针体现在把裸指针进行了一次面向对象的封装，在构造函数中初始化资源地址，在析构函数中负责释放资源</strong><br>2）<strong>利用栈上的对象出作用域自动析构这个特点，在智能指针的析构函数中保证释放资源</strong></p>
<p>所以智能指针一般都是定义在栈上的，在堆上定义也不是不可以，但是又成了裸指针，需要手动delete。<br>想要使用和裸指针一样，还需要重载*和-&gt;两个运算符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class CSmartPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CSmartPtr(T *ptr = nullptr) :mptr(ptr) &#123;&#125;</span><br><span class="line">	~CSmartPtr() &#123; delete mptr; &#125;</span><br><span class="line"></span><br><span class="line">	T&amp; operator*() &#123; return *mptr; &#125;</span><br><span class="line">	const T&amp; operator*()const &#123; return *mptr; &#125;</span><br><span class="line"></span><br><span class="line">	T* operator-&gt;() &#123; return mptr; &#125;</span><br><span class="line">	const T* operator-&gt;()const &#123; return mptr; &#125;</span><br><span class="line">private:</span><br><span class="line">	T *mptr;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CSmartPtr&lt;int&gt; ptr(new int);</span><br><span class="line">	*ptr = 20;</span><br><span class="line">	cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个智能指针和裸指针对比起来就十分相似了，但是仍然存在很大的问题。看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CSmartPtr&lt;int&gt; ptr1(new int);</span><br><span class="line">	CSmartPtr&lt;int&gt; ptr2(ptr1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个main函数运行后，代码直接崩溃。问题出现在默认拷贝构造函数使用的是浅拷贝，两个智能指针指向同一个资源，在释放时被两次delete，那肯定就会报错了。</p>
<h2 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h2><p>C++中提供的不带引用计数的智能指针有三种：auto_ptr、scoped_ptr、unique_ptr。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>首先看下auto_ptr的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class _Ty&gt;</span><br><span class="line">	class auto_ptr</span><br><span class="line">	&#123;	// wrap an object pointer to ensure destruction</span><br><span class="line">public:</span><br><span class="line">	typedef _Ty element_type;</span><br><span class="line"></span><br><span class="line">	explicit auto_ptr(_Ty * _Ptr = nullptr) noexcept</span><br><span class="line">		: _Myptr(_Ptr)</span><br><span class="line">		&#123;	// construct from object pointer</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	/*这里是auto_ptr的拷贝构造函数，</span><br><span class="line">	_Right.release()函数中，把_Right的_Myptr</span><br><span class="line">	赋为nullptr，也就是换成当前auto_ptr持有资源地址</span><br><span class="line">	*/</span><br><span class="line">	auto_ptr(auto_ptr&amp; _Right) noexcept</span><br><span class="line">		: _Myptr(_Right.release())</span><br><span class="line">		&#123;	// construct by assuming pointer from _Right auto_ptr</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	_Ty * release() noexcept</span><br><span class="line">		&#123;	// return wrapped pointer and give up ownership</span><br><span class="line">		_Ty * _Tmp = _Myptr;</span><br><span class="line">		_Myptr = nullptr;</span><br><span class="line">		return (_Tmp);</span><br><span class="line">		&#125;</span><br><span class="line">private:</span><br><span class="line">	_Ty * _Myptr;	// the wrapped object pointer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看出，只有最后一个智能指针持有资源，其他之前的智能指针最后都被赋值为nullptr，因此不能再被使用。考虑如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto_ptr&lt;int&gt; p1(new int);</span><br><span class="line">	/*</span><br><span class="line">	经过拷贝构造，p2指向了new int资源，</span><br><span class="line">	p1现在为nullptr了，如果使用p1，相当于</span><br><span class="line">	访问空指针了，很危险</span><br><span class="line">	*/</span><br><span class="line">	auto_ptr&lt;int&gt; p2 = p1;</span><br><span class="line">	*p1 = 10;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序，如果用户不了解auto_ptr的实现，代码就会出现严重的问题。有个面试问题：</p>
<p>auto_ptr能不能在容器中使用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;auto_ptr&lt;int&gt;&gt; vec;</span><br><span class="line">	vec.push_back(auto_ptr&lt;int&gt;(new int(10)));</span><br><span class="line">	vec.push_back(auto_ptr&lt;int&gt;(new int(20)));</span><br><span class="line">	vec.push_back(auto_ptr&lt;int&gt;(new int(30)));</span><br><span class="line">	// 这里可以打印出10</span><br><span class="line">	cout &lt;&lt; *vec[0] &lt;&lt; endl;</span><br><span class="line">	vector&lt;auto_ptr&lt;int&gt;&gt; vec2 = vec;</span><br><span class="line">	/* 这里由于上面做了vector容器的拷贝，相当于容器中</span><br><span class="line">	的每一个元素都进行了拷贝构造，原来vec中的智能指针</span><br><span class="line">	全部为nullptr了，再次访问就成访问空指针了，程序崩溃</span><br><span class="line">	*/</span><br><span class="line">	cout &lt;&lt; *vec[0] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以不要在容器中使用auto_ptr，C++已经建议不要使用auto_ptr了。</p>
<p><strong>总结：</strong>auto_ptr指针不带引用计数，那么它处理浅拷贝的问题，是直接把前面的auto_ptr都设置为nullptr，只让最后一个auto_ptr持有资源。</p>
<h3 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h3><p>其拷贝构造函数和拷贝赋值运算符直接被私有化或者被delete掉了，那就是让编译器保证不会发生智能指针的拷贝和赋值。</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr有一点和scoped_ptr做的一样，那就是把拷贝构造函数和operator=声明为delete。禁止对指针进行显式的拷贝或者赋值。</p>
<p>但是unique_ptr提供了带右值引用参数的两个函数。也就是说，unique_ptr可以通过右值引用进行拷贝和赋值。例如把unique_ptr作为函数返回值时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 示例1</span><br><span class="line">unique_ptr&lt;int&gt; ptr(new int);</span><br><span class="line">unique_ptr&lt;int&gt; ptr2 = std::move(ptr); // 使用了右值引用的拷贝构造</span><br><span class="line">ptr2 = std::move(ptr); // 使用了右值引用的operator=赋值重载函数</span><br><span class="line">// 示例2</span><br><span class="line">unique_ptr&lt;int&gt; test_uniqueptr()</span><br><span class="line">&#123;</span><br><span class="line">	unique_ptr&lt;int&gt; ptr1(new int);</span><br><span class="line">	return ptr1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	此处调用test_uniqueptr函数，在return ptr1代码</span><br><span class="line">	处，调用右值引用的拷贝构造函数，由ptr1拷贝构造ptr</span><br><span class="line">	*/</span><br><span class="line">	unique_ptr&lt;int&gt; ptr = test_uniqueptr();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带引用计数的智能指针shared-ptr、weak-ptr"><a href="#带引用计数的智能指针shared-ptr、weak-ptr" class="headerlink" title="带引用计数的智能指针shared_ptr、weak_ptr"></a>带引用计数的智能指针shared_ptr、weak_ptr</h2><p>当允许多个智能指针指向同一个资源时，每个智能指针都会给资源的引用计数+1，当一个智能指针析构时，同样会使得资源的引用计数-1，这样最后一个智能指针把资源的引用计数从1减到0时，说明该资源可以释放了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class RefCount &#123;</span><br><span class="line">public:</span><br><span class="line">    RefCount(T *ptr)</span><br><span class="line">        : m_ptr(ptr) &#123;</span><br><span class="line">        if (m_ptr != nullptr) &#123;</span><br><span class="line">            m_count = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addRef() &#123;</span><br><span class="line">        m_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    int delRef() &#123;</span><br><span class="line">       return --m_count;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">    int m_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 智能指针 保证能做到资源的自动释放</span><br><span class="line">// 利用栈上的对象出作用域自动析构的特征，来做到资源的自动释放</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class CSmartPointer &#123;</span><br><span class="line">public:</span><br><span class="line">    CSmartPointer(T *ptr = nullptr)</span><br><span class="line">        : m_ptr(ptr)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;CSmartPointer()&quot; &lt;&lt; endl;</span><br><span class="line">        m_RefCont = new RefCount&lt;T&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CSmartPointer() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~CSmartPointer()&quot; &lt;&lt; endl;</span><br><span class="line">        if (0 == m_RefCont-&gt;delRef()) &#123;</span><br><span class="line">            delete m_ptr;</span><br><span class="line">            m_ptr = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CSmartPointer(const CSmartPointer&lt;T&gt; &amp;pointer)</span><br><span class="line">        : m_ptr(pointer.m_ptr), m_RefCont(pointer.m_RefCont) &#123;</span><br><span class="line">        if (m_ptr != nullptr) &#123;</span><br><span class="line">            m_RefCont-&gt;addRef();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CSmartPointer&amp; operator=(const CSmartPointer&lt;T&gt; &amp;pointer) &#123;</span><br><span class="line">        if (this == &amp;pointer) &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        if (0 == m_RefCont-&gt;delRef()) &#123;</span><br><span class="line">            delete m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        m_ptr = pointer.m_ptr;</span><br><span class="line">        m_RefCont = pointer.m_RefCont;</span><br><span class="line">        m_RefCont-&gt;addRef();</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator*() &#123;</span><br><span class="line">        return *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator-&gt;() &#123;</span><br><span class="line">        return m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">    RefCount&lt;T&gt; *m_RefCont; //</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CSmartPointer&lt;int&gt; p1(new int );</span><br><span class="line">    CSmartPointer&lt;int&gt; p2(p1);</span><br><span class="line">    CSmartPointer&lt;int&gt; p3 (p2);</span><br><span class="line">    CSmartPointer&lt;int&gt; p4;</span><br><span class="line">    p4 = p1;</span><br><span class="line">    *p1 = 33;</span><br><span class="line">    cout &lt;&lt; *p1 &lt;&lt; *p2 &lt;&lt; *p3 &lt;&lt; *p4 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Shared-ptr的交叉引用问题"><a href="#Shared-ptr的交叉引用问题" class="headerlink" title="Shared_ptr的交叉引用问题"></a>Shared_ptr的交叉引用问题</h2><p>shared_ptr：强智能指针，可以改变资源的引用计数<br>weak_ptr：弱智能指针，不会改变资源的引用计数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class B;</span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    B() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    shared_ptr&lt;A&gt; pa(new A());</span><br><span class="line">    shared_ptr&lt;B&gt; pb(new B());</span><br><span class="line"></span><br><span class="line">    pa-&gt;b = pb;</span><br><span class="line">    pb-&gt;a = pa;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码导致资源无法释放，造成内存泄漏。<br>定义对象的时候使用强智能指针，引用对象的时候，使用弱智能指针。<br>弱智能指针是不会改变引用计数的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class B;</span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void testA() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;testA()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_ptr&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    B() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void func() &#123;</span><br><span class="line">        shared_ptr&lt;A&gt; pta = a.lock(); // 提升方法</span><br><span class="line">        if (pta != nullptr)</span><br><span class="line">            pta-&gt;testA();</span><br><span class="line">    &#125;</span><br><span class="line">    weak_ptr&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    shared_ptr&lt;A&gt; pa(new A());</span><br><span class="line">    shared_ptr&lt;B&gt; pb(new B());</span><br><span class="line"></span><br><span class="line">    pa-&gt;b = pb;</span><br><span class="line">    pb-&gt;a = pa;</span><br><span class="line">    pb-&gt;func();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弱智能指针是不能使用对象的，只是起到一个监视的作用。想要使用对象调用方法，只能先通过lock方法将类型提升，提升之后才能使用方法。</p>
<h2 id="多线程访问共享对象的线程安全问题"><a href="#多线程访问共享对象的线程安全问题" class="headerlink" title="多线程访问共享对象的线程安全问题"></a>多线程访问共享对象的线程安全问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A()&#123;cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    ~A()&#123;cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    void testA()&#123;cout &lt;&lt; &quot;非常好用的方法&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void handler01(A *p) &#123;</span><br><span class="line">    // p在访问A对象的时候，必须检查A对象是否存活，才能够访问对象</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line">    p-&gt;testA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A *p = new A();</span><br><span class="line">    thread t1(handler01, p);</span><br><span class="line">    delete p;</span><br><span class="line">    t1.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">A()</span><br><span class="line">~A()</span><br><span class="line">非常好用的方法</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>上述代码出现了错误，因为对象其实已经析构了，但是还是调用了方法。因此调用对象时必须检查对象是否存活，这就需要用到智能指针了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A()&#123;cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    ~A()&#123;cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    void testA()&#123;cout &lt;&lt; &quot;非常好用的方法&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void handler01(weak_ptr&lt;A&gt; pa) &#123;</span><br><span class="line">    // p在访问A对象的时候，必须检查A对象是否存活，才能够访问对象</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line">    shared_ptr&lt;A&gt; ps = pa.lock();</span><br><span class="line">    if (ps != nullptr)</span><br><span class="line">        ps-&gt;testA();</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A is deleted&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;A&gt; pa(new A);</span><br><span class="line">        thread t1(handler01, weak_ptr&lt;A&gt;(pa));</span><br><span class="line">        t1.detach();</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(20));</span><br><span class="line">    // t1.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">A()</span><br><span class="line">~A()</span><br><span class="line">A is deleted</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="自定义删除器deletor"><a href="#自定义删除器deletor" class="headerlink" title="自定义删除器deletor"></a>自定义删除器deletor</h2><p>智能指针：能够保证资源的绝对释放</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">智能指针的删除器 deletor</span><br><span class="line">智能指针：能够保证资源的绝对释放 delete ptr</span><br><span class="line">～unique_ptr() &#123;是一个函数对象的调用 deletor(ptr);&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typaname T&gt;</span><br><span class="line">class Deletor &#123;</span><br><span class="line">public:</span><br><span class="line">	void operator()(T *ptr) &#123;</span><br><span class="line">		delete ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class MyDeletor &#123;</span><br><span class="line">public:</span><br><span class="line">    void operator()(T *ptr) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call mydelete&quot; &lt;&lt; endl;</span><br><span class="line">        delete[] ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;int, MyDeletor&lt;int&gt;&gt; ptr(new int[1000]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">call mydelete</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class MyFileDeletor &#123;</span><br><span class="line">public:</span><br><span class="line">    void operator()(T *ptr) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call myfiledelete&quot; &lt;&lt; endl;</span><br><span class="line">        fclose(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;FILE, MyFileDeletor&lt;FILE&gt;&gt; ptr1(fopen(&quot;data.txt&quot;, &quot;w&quot;));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 不同类型的deletor不同</span><br><span class="line">// 可以使用lambda表达式来代替函数对象,就不用创建那两个类了；</span><br><span class="line">unique_ptr&lt;int, function&lt;void(int*)&gt;&gt; ptr(new int[100], [](int *p) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;lambda my deletor&quot; &lt;&lt; endl;</span><br><span class="line">    delete []p;</span><br><span class="line">&#125;);</span><br><span class="line">unique_ptr&lt;FILE , function&lt;void(FILE *)&gt;&gt; ptr1(fopen(&quot;a.txt&quot;, &quot;w&quot;), [](FILE *p) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;lambda my file deletor&quot; &lt;&lt; endl;</span><br><span class="line">    fclose(p);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="绑定器和函数对象"><a href="#绑定器和函数对象" class="headerlink" title="绑定器和函数对象"></a>绑定器和函数对象</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*绑定器和函数对象operator</span><br><span class="line">C++ STL中的绑定器</span><br><span class="line">1、bind1st：operator（）的第一个形参变量绑定成一个特定的值</span><br><span class="line">bind2st：operator（）的第二个形参变量绑定成一个特定的值</span><br><span class="line">2、C++11 从Boost库中引入了bind绑定器和function函数对象机制</span><br><span class="line">3、lambda表达式 底层依赖函数对象的机制实现</span><br><span class="line">*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    srand(time(nullptr));</span><br><span class="line">    for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        vec.push_back(rand() % 100 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    showContainer(vec);</span><br><span class="line">    sort(vec.begin(), vec.end());</span><br><span class="line">    showContainer(vec);</span><br><span class="line">    sort(vec.begin(), vec.end(), greater&lt;int&gt;());</span><br><span class="line">    showContainer(vec);</span><br><span class="line">	// 寻找第一个小于70的数字（要求是将70按照顺序插入到数列当中）</span><br><span class="line">    auto it = find_if(vec.begin(), vec.end(), bind1st( greater&lt;int&gt;(), 70));</span><br><span class="line">    vec.insert(it, 70);</span><br><span class="line">    showContainer(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="底层原理实现"><a href="#底层原理实现" class="headerlink" title="底层原理实现"></a>底层原理实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">既然lambda表达式只能使用在语句当中，如果想跨语句使用之前定义好的lambda表达式，</span><br><span class="line">怎么办？用什么类型来表示lambda表达式？</span><br><span class="line">当然是用function类型来表示函数对象的类型了   bind1st/bind2nd bind绑定器</span><br><span class="line"></span><br><span class="line">lambda表达式 =》 函数对象   </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Data(int val1 = 10, int val2 = 10) :ma(val1), mb(val2) &#123;&#125;</span><br><span class="line">	//bool operator&gt;(const Data &amp;data)const &#123; return ma &gt; data.ma; &#125;</span><br><span class="line">	//bool operator&lt;(const Data &amp;data)const &#123; return ma &lt; data.ma; &#125;</span><br><span class="line">	int ma;</span><br><span class="line">	int mb;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	// 优先级队列</span><br><span class="line">	//priority_queue&lt;Data&gt; queue;</span><br><span class="line">	using FUNC = function&lt;bool(Data&amp;, Data&amp;)&gt;;</span><br><span class="line">	priority_queue&lt;Data, vector&lt;Data&gt;, FUNC&gt; </span><br><span class="line">		maxHeap([](Data &amp;d1, Data &amp;d2)-&gt;bool</span><br><span class="line">		&#123;</span><br><span class="line">			return d1.mb &gt; d2.mb;</span><br><span class="line">		&#125;);</span><br><span class="line">	maxHeap.push(Data(10, 20));</span><br><span class="line">	maxHeap.push(Data(15, 15));</span><br><span class="line">	maxHeap.push(Data(20, 10));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 智能指针自定义删除器   delete p;  FILE*   fclose(FILE*)</span><br><span class="line">	//unique_ptr&lt;FILE, function&lt;void(FILE*)&gt;&gt; </span><br><span class="line">		//ptr1(fopen(&quot;data.txt&quot;, &quot;w&quot;), [](FILE *pf) &#123;fclose(pf); &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">	map&lt;int, function&lt;int(int, int)&gt;&gt; caculateMap;</span><br><span class="line">	caculateMap[1] = [](int a, int b)-&gt;int &#123;return a + b; &#125;;</span><br><span class="line">	caculateMap[2] = [](int a, int b)-&gt;int &#123;return a - b; &#125;;</span><br><span class="line">	caculateMap[3] = [](int a, int b)-&gt;int &#123;return a * b; &#125;;</span><br><span class="line">	caculateMap[4] = [](int a, int b)-&gt;int &#123;return a / b; &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;选择:&quot;;</span><br><span class="line">	int choice;</span><br><span class="line">	cin &gt;&gt; choice;</span><br><span class="line">	cout &lt;&lt; &quot;10 + 15:&quot; &lt;&lt; caculateMap[choice](10, 15) &lt;&lt; endl;</span><br><span class="line">#endif</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">/*</span><br><span class="line">C++11 函数对象的升级版 =》 lambda表达式</span><br><span class="line">函数对象的缺点：</span><br><span class="line">使用在泛型算法参数传递   比较性质/自定义操作  优先级队列  智能指针</span><br><span class="line"></span><br><span class="line">lambda表达式的语法：</span><br><span class="line">[捕获外部变量](形参列表)-&gt;返回值&#123;操作代码&#125;;</span><br><span class="line"></span><br><span class="line">如果lambda表达式的返回值不需要，那么&quot;-&gt;返回值&quot;可以省略的</span><br><span class="line"></span><br><span class="line">[捕获外部变量]</span><br><span class="line">[]：表示不捕获任何外部变量</span><br><span class="line">[=]：以传值的方式捕获外部的所有变量</span><br><span class="line">[&amp;]：以传引用的方式捕获外部的所有变量</span><br><span class="line">[this]：捕获外部的this指针</span><br><span class="line">[=,&amp;a]：以传值的方式捕获外部的所有变量，但是a变量以传引用的方式捕获</span><br><span class="line">[a, b]：以值传递的方式捕获外部变量a和b</span><br><span class="line">[a, &amp;b]：a以值传递捕获，b以传引用的方式捕获</span><br><span class="line">*/</span><br><span class="line">template&lt;typename T=void&gt;</span><br><span class="line">class TestLambda01</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	TestLambda01() &#123;&#125;</span><br><span class="line">	void operator()()const</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T = int&gt;</span><br><span class="line">class TestLambda02</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	TestLambda02() &#123;&#125;</span><br><span class="line">	int operator()(int a, int b)const</span><br><span class="line">	&#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T = int&gt;</span><br><span class="line">class TestLambda03</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	TestLambda03(int &amp;a, int &amp;b):ma(a), mb(b) &#123;&#125;</span><br><span class="line">	void operator()()const</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp = ma;</span><br><span class="line">		ma = mb;</span><br><span class="line">		mb = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int &amp;ma;</span><br><span class="line">	int &amp;mb;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; vec;</span><br><span class="line">	for (int i = 0; i &lt; 20; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.push_back(rand() % 100 + 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort(vec.begin(), vec.end(), </span><br><span class="line">		[](int a, int b)-&gt;bool</span><br><span class="line">		&#123;</span><br><span class="line">			return a &gt; b;</span><br><span class="line">		&#125;);</span><br><span class="line">	for (int val : vec)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	// 65按序插入序列  要找第一个小于65的数字</span><br><span class="line">	auto it = find_if(vec.begin(), vec.end(), </span><br><span class="line">		[](int a)-&gt;bool &#123;return a &lt; 65; &#125;);</span><br><span class="line">	if (it != vec.end())</span><br><span class="line">	&#123;</span><br><span class="line">		vec.insert(it, 65);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int val : vec)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(vec.begin(), vec.end(), [](int a)</span><br><span class="line">	&#123;</span><br><span class="line">		if(a % 2 == 0)</span><br><span class="line">			cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">	auto func1 = []()&#123;cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">	func1();</span><br><span class="line"></span><br><span class="line">	auto func2 = [](int a, int b)-&gt;int &#123;return a + b; &#125;;</span><br><span class="line">	cout&lt;&lt;func2(20, 30)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	auto func3 = [&amp;]() // “a”: 无法在非可变 lambda 中修改通过复制捕获</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = tmp;</span><br><span class="line">	&#125;;</span><br><span class="line">	func3();</span><br><span class="line">	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	TestLambda01&lt;&gt; t1;</span><br><span class="line">	t1();</span><br><span class="line"></span><br><span class="line">	TestLambda02&lt;&gt; t2;</span><br><span class="line">	cout &lt;&lt; t2(20, 30) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	TestLambda03&lt;&gt; t3(a, b);</span><br><span class="line">	t3();</span><br><span class="line">#endif</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h1 id="c-11内容总结"><a href="#c-11内容总结" class="headerlink" title="c++11内容总结"></a>c++11内容总结</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">一、关键字和语法</span><br><span class="line">auto：可以根据右值，推导出右值的类型，然后左边变量的类型也就已知了</span><br><span class="line">nullptr：给指针专用（能够和整数进行区分） #define NULL 0</span><br><span class="line">foreach：可以遍历数组和容器</span><br><span class="line">for（Tpye val：container）&#123;</span><br><span class="line"></span><br><span class="line">&#125; // 底层就是通过迭代器来实现的</span><br><span class="line">右值引用：move语义函数和forward类型完美转发</span><br><span class="line">模板的一个特性：typename...A 表示可变参数</span><br><span class="line"></span><br><span class="line">二、绑定器和函数对象</span><br><span class="line">function：函数对象</span><br><span class="line">bind：绑定器 bind1st bind2st ： 二元函数对象转化为一元函数对象</span><br><span class="line">lambda 表达式</span><br><span class="line"></span><br><span class="line">三、智能指针</span><br><span class="line">shared_ptr和weak_ptr</span><br><span class="line"></span><br><span class="line">四、容器</span><br><span class="line">set和map：红黑树</span><br><span class="line">unordered_set和unordered_map：哈希表</span><br><span class="line">array： 数组 vector</span><br><span class="line">forward_list：单向链表</span><br><span class="line"></span><br><span class="line">五、C++语言级别的多线程编程</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h1 id="C-语言级别的多线程编程"><a href="#C-语言级别的多线程编程" class="headerlink" title="C++语言级别的多线程编程"></a>C++语言级别的多线程编程</h1><p>好处是可以跨平台。其实只是封装了操作系统的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 线程内容：</span><br><span class="line"> * 一、如何创建并启动一个线程</span><br><span class="line"> * std::thread定义一个线程对象，传入线程所需要的线程函数和参数，线程自动开启</span><br><span class="line"> * 二、子线程如何结束</span><br><span class="line"> * 子线程函数运行完成，线程就结束了</span><br><span class="line"> * 三、主线程如何处理子线程</span><br><span class="line"> * join：等待t线程结束，当前线程继续向下运行</span><br><span class="line"> * detach：把t线程设置为分离线程，主线程结束，整个进程结束，所有子线程都自动结束了</span><br><span class="line"> */</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;thread&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">void threadHandle1() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;hello thread!&quot; &lt;&lt; endl;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(2));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;hello main 001&quot; &lt;&lt; endl;</span><br><span class="line">    // 创建了一个线程对象，传入一个线程函数，新线程就开始运行了</span><br><span class="line">    thread t1(threadHandle1);</span><br><span class="line">    // 主线程等待子线程结束，主线程继续往下运行</span><br><span class="line">    t1.join();</span><br><span class="line">    // 把子线程设置为分离线程</span><br><span class="line">//    t1.detach();</span><br><span class="line">    cout &lt;&lt; &quot;hell main&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-thread-模拟车站三个窗口卖票的程序"><a href="#C-thread-模拟车站三个窗口卖票的程序" class="headerlink" title="C++ thread 模拟车站三个窗口卖票的程序"></a>C++ thread 模拟车站三个窗口卖票的程序</h2>
    
  </div>

  
  <!-- Post Copyright -->

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/Cpp/">Cpp</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2022/05/27/C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">C++右值引用</span>  
        <span class="prev-text nav-mobile">上一篇</span>  
      </a>  
      
      
      <a class="next" href="/2022/04/16/Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">  
        <span class="next-text nav-default">Cpp学习笔记</span>  
        <span class="prev-text nav-mobile">下一篇</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="gitalk-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/fengxuegt" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2021 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">枫雪</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
  

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css" />


<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'Ov23linyjoE7z3V3Gako',
    clientSecret: '4bbd23045cfc104a6cf9f988ca2051cf86f1b25b',
    repo: 'blog-review',
    owner: 'fengxuegt',
    admin: ['fengxuegt'],
    id: md5(location.pathname),
    
    language: '',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  
    
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>

</html>